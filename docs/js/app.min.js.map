{"version":3,"sources":["docs/js/app.js"],"names":["GlslCanvasWrapper","createShader","glsl","source","type","gl","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","lastError","getShaderInfoLog","console","error","trigger","deleteShader","createProgram","shaders","optAttribs","optLocations","ii","program","length","attachShader","bindAttribLocation","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","log","deleteProgram","GlslCanvas","prototype","render","this","visible","canvas","getBoundingClientRect","top","height","window","innerHeight","document","documentElement","clientHeight","forceRender","animated","paused","date","Date","now","performance","tex","timeDelta","timePrev","nDelta","uniform","nTime","timeLoad","nDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","width","texureIndex","textures","uniformTexture","buffers","Object","keys","key","buffer","useProgram","bundle","bind","drawArrays","TRIANGLES","bindFramebuffer","FRAMEBUFFER","viewport","change","method","name","value","Array","slice","call","arguments","uniforms","location","getUniformLocation","apply","concat","loadBuffers","i","W","H","texture","createTexture","createFramebuffer","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","framebufferTexture2D","COLOR_ATTACHMENT0","activeTexture","TEXTURE0","uniform1i","vertex","vertexString","VERTEX_SHADER","fragment","common","FRAGMENT_SHADER","isValid","options","main","onGlslError","message","errors","warnings","replace","m","l","v","t","li","encodeURI","JSON","stringify","uri","Number","push","output","join","querySelector","setAttribute","innerHTML","addEventListener","url","callback","request","RegExp","match","content","resize","ri","premultipliedAlpha","preserveDrawingBuffer","backgroundColor","init","w","offsetWidth","h","offsetHeight","style","on","trim","load","filtering","repeat","clearTimeout","setTimeout","createCanvas","XMLHttpRequest","open","responseText","send"],"mappings":"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","file":"app.min.js","sourcesContent":["/* global window, document, console, GlslCanvas, CaptureService, GuiService, TrailsService, CameraService, Stats, dat */\n\n(function () {\n    'use strict';\n\n    var GlslCanvasWrapper = function () {\n        // TODO LOAD CREATE MULTIPLE PROGRAMS\n        /*\n        lass GLProgram {\n        constructor (vertexShader, fragmentShader) {\n            this.uniforms = {};\n            this.program = gl.createProgram();\n\n            gl.attachShader(this.program, vertexShader);\n            gl.attachShader(this.program, fragmentShader);\n            gl.linkProgram(this.program);\n\n            if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n                throw gl.getProgramInfoLog(this.program);\n            }\n\n            const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n            for (let i = 0; i < uniformCount; i++) {\n                const uniformName = gl.getActiveUniform(this.program, i).name;\n                this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);\n            }\n        }\n        bind () {\n            gl.useProgram(this.program);\n        }\n        }\n        */\n\n        function GlslCanvasWrapper(canvas, options) {\n            return new GlslCanvas(canvas, options);\n        }\n\n        GlslCanvas.prototype.render = render;\n        GlslCanvas.prototype.uniform = uniform;\n        GlslCanvas.prototype.loadBuffers = loadBuffers;\n\n        /*\n        function createFrameBuffer(gl, i, W, H) {\n            gl.activeTexture(gl.TEXTURE0 + i);\n            var texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            var buffer = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            gl.viewport(0, 0, W, H);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            console.log(W, H, i);\n            return [texture, buffer, i];\n        }\n        */\n\n        function loadBuffers(buffers) {\n            var glsl = this,\n                gl = glsl.gl, i = 0;\n            glsl.buffers = {};\n\n            gl.bundle = function (program, i, W, H) {\n                var texture = gl.createTexture();\n                var buffer = gl.createFramebuffer();\n                var uniform = gl.getUniformLocation(program, \"u_buffer_\" + i);\n                gl.bindTexture(gl.TEXTURE_2D, texture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                return {\n                    texture: texture,\n                    buffer: buffer,\n                    uniform: uniform,\n                    bind: function () {\n                        gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n                        /*\n                        gl.bindBuffer(gl.FRAMEBUFFER, buffer);\n                        */\n                        gl.viewport(0, 0, W, H);\n                        /*\n                // draw first pass, the one which supposed to write data for the channel 0\n                // it'll use fragment shader for bufferA\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n                // pass texture as channel 0\n                */\n                        gl.activeTexture(gl.TEXTURE0 + i);\n                        gl.bindTexture(gl.TEXTURE_2D, texture);\n                        gl.uniform1i(uniform, 0);\n\n                        // draw second pass, the one with uses channel 0\n                        // There 're a lot of materials about rendering to texture, for example here.\n                    }\n                };\n            };\n\n            var vertex = createShader(glsl, glsl.vertexString, gl.VERTEX_SHADER);\n            for (var key in buffers) {\n                var buffer = buffers[key];\n                var fragment = createShader(glsl, buffer.common + buffer.fragment, gl.FRAGMENT_SHADER);\n                // If Fragment shader fails load a empty one to sign the error\n                if (!fragment) {\n                    fragment = createShader(glsl, 'void main(){\\n\\tgl_FragColor = vec4(1.0);\\n}', gl.FRAGMENT_SHADER);\n                    glsl.isValid = false;\n                } else {\n                    glsl.isValid = true;\n                }\n                // Create and use program\n                var program = createProgram(glsl, [vertex, fragment]);\n                buffer.program = program;\n\n                // buffer.frame = createFrameBuffer(gl, i, glsl.canvas.width, glsl.canvas.height);\n                buffer.bundle = gl.bundle(program, i, glsl.canvas.width, glsl.canvas.height);\n                console.log('buffer.fragment', i, buffer.fragment, buffer.bundle);\n\n                // console.log('buffer', buffer);\n                glsl.buffers[key] = buffer;\n                // glsl.gl.useProgram(program);\n                // Delete shaders\n                gl.deleteShader(fragment);\n                i++;\n            }\n            gl.deleteShader(vertex);\n            /*\n            gl.binder = function () {\n                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(0);\n                return function (buffer) {\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n                    // gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n                    gl.drawArrays(gl.TRIANGLES, 0, 6);\n                };\n            }();\n            */\n        }\n\n        // ex: program.uniform('3f', 'position', x, y, z);\n        function uniform(method, type, name) { // 'value' is a method-appropriate arguments list\n            var value = Array.prototype.slice.call(arguments).slice(3);\n            var glsl = this, gl = glsl.gl;\n            glsl.uniforms[name] = glsl.uniforms[name] || {};\n            var uniform = glsl.uniforms[name];\n            var change = true; // isDiff(uniform.value, value);\n            if (change || glsl.change || uniform.location === undefined || uniform.value === undefined) {\n                uniform.name = name;\n                uniform.value = value;\n                uniform.type = type;\n                uniform.method = 'uniform' + method;\n                uniform.location = gl.getUniformLocation(glsl.program, name);\n                gl[uniform.method].apply(gl, [uniform.location].concat(uniform.value));\n                // TODO RENDER MULTIPLE BUFFERS            \n                if (glsl.buffers && Object.keys(glsl.buffers).length > 0) {\n                    for (var key in glsl.buffers) {\n                        var buffer = glsl.buffers[key];\n                        uniform.location = gl.getUniformLocation(buffer.program, name);\n                        gl[uniform.method].apply(gl, [uniform.location].concat(uniform.value));\n                        console.log(buffer, uniform);\n                    }\n                }\n            }\n        }\n\n        function render() {\n            var glsl = this,\n                gl = glsl.gl;\n\n            glsl.visible = isCanvasVisible(glsl.canvas);\n            if (glsl.forceRender || (glsl.animated && glsl.visible && !glsl.paused)) {\n                var date = new Date();\n                var now = performance.now();\n                glsl.timeDelta = (now - glsl.timePrev) / 1000.0;\n                glsl.timePrev = now;\n                if (glsl.nDelta > 1) {\n                    // set the delta time uniform\n                    glsl.uniform('1f', 'float', 'u_delta', glsl.timeDelta);\n                }\n\n                if (glsl.nTime > 1) {\n                    // set the elapsed time uniform\n                    glsl.uniform('1f', 'float', 'u_time', (now - glsl.timeLoad) / 1000.0);\n                }\n\n                if (glsl.nDate) {\n                    // Set date uniform: year/month/day/time_in_sec\n                    glsl.uniform('4f', 'float', 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);\n                }\n\n                // set the resolution uniform\n                glsl.uniform('2f', 'vec2', 'u_resolution', glsl.canvas.width, glsl.canvas.height);\n\n                glsl.texureIndex = 0;\n                for (var tex in glsl.textures) {\n                    glsl.uniformTexture(tex);\n                }\n\n                // TODO RENDER MULTIPLE BUFFERS            \n                if (glsl.buffers && Object.keys(glsl.buffers).length > 0) {\n                    for (var key in glsl.buffers) {\n                        var buffer = glsl.buffers[key];\n                        /*\n                        glsl.uniformTexture(key, buffer.frame[0], {\n                            filtering: 'mipmap',\n                            repeat: true,\n                        });\n                        */\n                        /*\n                        glsl.uniform('1i', 'sampler2D', key, i);\n                        glsl.textures[name].bind(this.texureIndex);\n                        glsl.uniform('2f', 'vec2', name + 'Resolution', this.textures[name].width, this.textures[name].height);\n                        glsl.texureIndex++;\n                        */\n                        gl.useProgram(buffer.program);\n                        // gl.binder(buffer.frame[1]);\n                        buffer.bundle.bind();\n                        // gl.bindFramebuffer(gl.FRAMEBUFFER, buffer.bundle.buffer);\n                        gl.drawArrays(gl.TRIANGLES, 0, 6);\n                        // console.log(key);\n                    }\n                    gl.useProgram(glsl.program);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n                }\n\n                // Draw the rectangle.\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n                // Trigger event\n\n                glsl.trigger('render', {});\n                glsl.change = false;\n                glsl.forceRender = false;\n            }\n        }\n\n        function createShader(glsl, source, type) {\n            var gl = glsl.gl;\n            var shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n            if (!compiled) {\n                // Something went wrong during compilation; get the error\n                var lastError = gl.getShaderInfoLog(shader);\n                console.error('*** Error compiling shader ' + shader + ':' + lastError);\n                glsl.trigger('error', {\n                    shader: shader,\n                    source: source,\n                    type: type,\n                    error: lastError\n                });\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        function createProgram(glsl, shaders, optAttribs, optLocations) {\n            var gl = glsl.gl;\n            var ii;\n            var program = gl.createProgram();\n            for (ii = 0; ii < shaders.length; ++ii) {\n                gl.attachShader(program, shaders[ii]);\n            }\n            if (optAttribs) {\n                for (ii = 0; ii < optAttribs.length; ++ii) {\n                    gl.bindAttribLocation(\n                        program,\n                        optLocations ? optLocations[ii] : ii,\n                        optAttribs[ii]);\n                }\n            }\n            gl.linkProgram(program);\n            // Check the link status\n            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n            if (!linked) {\n                // something went wrong with the link\n                lastError = gl.getProgramInfoLog(program);\n                console.log('Error in program linking:' + lastError);\n                gl.deleteProgram(program);\n                return null;\n            }\n            return program;\n        }\n\n        function isCanvasVisible(canvas) {\n            return ((canvas.getBoundingClientRect().top + canvas.height) > 0) && (canvas.getBoundingClientRect().top < (window.innerHeight || document.documentElement.clientHeight));\n        }\n\n        return GlslCanvasWrapper;\n\n    }();\n\n    var options = window.options = {\n        vertex: '',\n        fragment: '',\n        main: '',\n        buffers: {},\n    };\n\n    function init() {\n        getResource(\"shaders/buffers.glsl\", function (fragment) {\n            // (?<=\\/{2} u_buffer_)(\\d+).*((.|\\n)*?)(?=\\/{2} [u_buffer|main]|\\z)\n            // (?<=\\/{2} main).*((.|\\n)*?)(?=\\/{2} u_buffer|\\z)\n            fragment = fragment.replace(new RegExp('(/{2} u_buffer_)(\\\\d+).*((.|\\\\n)*?)(?=/{2} [u_buffer|main]|\\\\z)', 'g'), function (match, name, i, fragment) {\n                // console.log('u_buffer_.replace', arguments);\n                options.buffers['u_buffer_' + i] = {\n                    fragment: fragment,\n                };\n                return '';\n            });\n\n            fragment = fragment.replace(new RegExp('(/{2} main).*((.|\\\\n)*)(?=/{2} u_buffer|$)', 'g'), function (match, name, main) {\n                options.main = main;\n                return '';\n            });\n\n            // console.log('getResource', fragment, options.buffers);\n            for (var key in options.buffers) {\n                options.buffers[key].common = fragment;\n            }\n\n            options.fragment = fragment + (options.main || '');\n            // console.log('fragment', options.fragment);\n            createCanvas();\n        });\n    }\n\n    function createCanvas() {\n        var content = document.querySelector('.content');\n        var canvas = document.querySelector('.shader');\n\n        resize(true);\n\n        var glsl = new GlslCanvasWrapper(canvas, {\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: true,\n            backgroundColor: 'rgba(1,1,1,1)',\n        });\n        glsl.on('error', onGlslError);\n        glsl.on('render', function () {\n            glsl.forceRender = true;\n        });\n\n        load();\n\n        function load() {\n            var options = window.options;\n            document.querySelector('.errors').setAttribute('class', 'errors');\n            document.querySelector('.welcome').setAttribute('class', 'welcome');\n            options.vertex = options.vertex.trim().length > 0 ? options.vertex : null;\n            options.fragment = options.fragment.trim().length > 0 ? options.fragment : null;\n            if (options.fragment || options.vertex) {\n                document.querySelector('body').setAttribute('class', 'ready');\n            } else {\n                document.querySelector('body').setAttribute('class', 'empty');\n            }\n            glsl.load(options.fragment, options.vertex);\n            glsl.loadBuffers(options.buffers);\n            if (options.textures) {\n                for (var t in options.textures) {\n                    glsl.uniformTexture('u_texture_' + t, options.textures[t], {\n                        filtering: 'mipmap',\n                        repeat: true,\n                    });\n                }\n            }\n            // console.log('glsl', glsl);\n            /*\n            gui.load(options.uniforms);\n            glsl.setUniforms(gui.uniforms());\n            */\n        }\n\n        function resize(init) {\n            var w = content.offsetWidth;\n            var h = content.offsetHeight;\n            canvas.style.width = w + 'px';\n            canvas.style.height = h + 'px';\n            if (init) {\n                canvas.width = w;\n                canvas.height = h;\n            } else {\n                glsl.resize();\n            }\n        }\n\n        var ri;\n\n        function onResize() {\n            if (ri) {\n                clearTimeout(ri);\n            }\n            ri = setTimeout(resize, 50);\n        }\n\n        window.addEventListener('resize', onResize);\n\n        resize();\n    }\n\n    function onGlslError(message) {\n        console.log('onGlslError.error', message.error);\n        var options = window.options;\n        var errors = [],\n            warnings = [];\n        message.error.replace(/ERROR: \\d+:(\\d+): \\'(.+)\\' : (.+)/g, function (m, l, v, t) {\n            var message = 'ERROR (' + v + ') ' + t;\n            var li = '<li><a class=\"error\" unselectable href=\"' + encodeURI('command:glsl-canvas.revealGlslLine?' + JSON.stringify([options.uri, Number(l), message])) + '\"><span class=\"line\">ERROR line ' + Number(l) + '</span> <span class=\"value\" title=\"' + v + '\">' + v + '</span> <span class=\"text\" title=\"' + t + '\">' + t + '</span></a></li>';\n            errors.push(li);\n            return li;\n        });\n        message.error.replace(/WARNING: \\d+:(\\d+): \\'(.*\\n*|.*|\\n*)\\' : (.+)/g, function (m, l, v, t) {\n            var li = '<li><a class=\"warning\" unselectable href=\"' + encodeURI('command:glsl-canvas.revealGlslLine?' + JSON.stringify([options.uri, Number(l), message])) + '\"><span class=\"line\">WARN line ' + Number(l) + '</span> <span class=\"text\" title=\"' + t + '\">' + t + '</span></a></li>';\n            warnings.push(li);\n            return li;\n        });\n        var output = '<div class=\"errors-content\"><p>glslCanvas error</p><ul>';\n        output += errors.join('\\n');\n        output += warnings.join('\\n');\n        output += '</ul></div>';\n        document.querySelector('.errors').setAttribute('class', 'errors active');\n        document.querySelector('.errors').innerHTML = output;\n        document.querySelector('body').setAttribute('class', 'idle');\n    }\n\n    function getResource(url, callback) {\n        var request = new XMLHttpRequest();\n        request.open('GET', url, true);\n        request.addEventListener('load', function () {\n            callback(request.responseText);\n        });\n        request.send();\n    }\n\n    window.addEventListener('load', init);\n\n}());"]}