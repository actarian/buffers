{"version":3,"sources":["docs/js/app.js"],"names":["options","window","vertex","fragment","main","buffers","onGlslError","message","console","log","error","errors","warnings","replace","m","l","v","t","li","encodeURI","JSON","stringify","uri","Number","push","output","join","document","querySelector","setAttribute","innerHTML","addEventListener","url","callback","request","key","RegExp","match","name","index","arguments","common","content","canvas","resize","ri","glsl","GlslCanvas","premultipliedAlpha","preserveDrawingBuffer","backgroundColor","init","w","offsetWidth","h","offsetHeight","style","width","height","on","forceRender","trim","length","load","loadBuffers","textures","uniformTexture","filtering","repeat","clearTimeout","setTimeout","createCanvas","XMLHttpRequest","open","responseText","send","createFrameBuffer","gl","W","H","internalFormat","format","type","param","activeTexture","TEXTURE0","texture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","frameBuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","viewport","clear","COLOR_BUFFER_BIT","createShader","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","lastError","getShaderInfoLog","trigger","deleteShader","createProgram","shaders","optAttribs","optLocations","ii","program","attachShader","bindAttribLocation","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","prototype","render","this","visible","getBoundingClientRect","top","innerHeight","documentElement","clientHeight","animated","paused","date","Date","now","performance","tex","timeDelta","timePrev","nDelta","uniform","nTime","timeLoad","nDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","texureIndex","Object","keys","buffer","frame","useProgram","binder","drawArrays","TRIANGLES","change","vertexString","VERTEX_SHADER","FRAGMENT_SHADER","isValid","i","RGBA","UNSIGNED_BYTE","NEAREST","bindBuffer","ARRAY_BUFFER","createBuffer","bufferData","Float32Array","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","Uint16Array","vertexAttribPointer","FLOAT","enableVertexAttribArray","destination","drawElements","UNSIGNED_SHORT"],"mappings":"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","file":"app.min.js","sourcesContent":["/* global window, document, console, GlslCanvas, CaptureService, GuiService, TrailsService, CameraService, Stats, dat */\n\n(function () {\n    'use strict';\n\n    var options = window.options = {\n        vertex: '',\n        fragment: '',\n        main: '',\n        buffers: {},\n    };\n\n    function init() {\n        getResource(\"shaders/buffers.glsl\", function (fragment) {\n            // (?<=\\/{2} u_buffer_)(\\d+).*((.|\\n)*?)(?=\\/{2} [u_buffer|main]|\\z)\n            // (?<=\\/{2} main).*((.|\\n)*?)(?=\\/{2} u_buffer|\\z)\n            fragment = fragment.replace(new RegExp('(/{2} u_buffer_)(\\\\d+).*((.|\\\\n)*?)(?=/{2} [u_buffer|main]|\\\\z)', 'g'), function (match, name, index, fragment) {\n                // console.log('u_buffer_.replace', arguments);\n                options.buffers['u_buffer_' + index] = {\n                    fragment: fragment,\n                };\n                return '';\n            });\n\n            console.log('fragment-------', fragment);\n\n            fragment = fragment.replace(new RegExp('(/{2} main)((.|\\\\n)*?)(?=/{2} u_buffer|\\\\z)', 'g'), function (match, name, main) {\n                console.log('main.replace---------', arguments);\n                options.main = main;\n                return '';\n            });\n\n            console.log('getResource-------', fragment, options.buffers);\n            for (var key in options.buffers) {\n                options.buffers[key].common = fragment;\n            }\n\n            options.fragment = fragment + (options.main || '');\n            createCanvas();\n        });\n    }\n\n    function createCanvas() {\n        var content = document.querySelector('.content');\n        var canvas = document.querySelector('.shader');\n\n        resize(true);\n\n        var glsl = new GlslCanvas(canvas, {\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: true,\n            backgroundColor: 'rgba(1,1,1,1)',\n        });\n        glsl.on('error', onGlslError);\n        glsl.on('render', function () {\n            glsl.forceRender = true;\n        });\n\n        load();\n\n        function load() {\n            var options = window.options;\n            document.querySelector('.errors').setAttribute('class', 'errors');\n            document.querySelector('.welcome').setAttribute('class', 'welcome');\n            options.vertex = options.vertex.trim().length > 0 ? options.vertex : null;\n            options.fragment = options.fragment.trim().length > 0 ? options.fragment : null;\n            if (options.fragment || options.vertex) {\n                document.querySelector('body').setAttribute('class', 'ready');\n            } else {\n                document.querySelector('body').setAttribute('class', 'empty');\n            }\n            glsl.load(options.fragment, options.vertex);\n            glsl.loadBuffers(options.buffers);\n            if (options.textures) {\n                for (var t in options.textures) {\n                    glsl.uniformTexture('u_texture_' + t, options.textures[t], {\n                        filtering: 'mipmap',\n                        repeat: true,\n                    });\n                }\n            }\n            console.log('glsl', glsl);\n            /*\n            gui.load(options.uniforms);\n            glsl.setUniforms(gui.uniforms());\n            */\n        }\n\n        function resize(init) {\n            var w = content.offsetWidth;\n            var h = content.offsetHeight;\n            canvas.style.width = w + 'px';\n            canvas.style.height = h + 'px';\n            if (init) {\n                canvas.width = w;\n                canvas.height = h;\n            } else {\n                glsl.resize();\n            }\n        }\n\n        var ri;\n\n        function onResize() {\n            if (ri) {\n                clearTimeout(ri);\n            }\n            ri = setTimeout(resize, 50);\n        }\n\n        window.addEventListener('resize', onResize);\n\n        resize();\n    }\n\n    function onGlslError(message) {\n        console.log('onGlslError.error', message.error);\n        var options = window.options;\n        var errors = [],\n            warnings = [];\n        message.error.replace(/ERROR: \\d+:(\\d+): \\'(.+)\\' : (.+)/g, function (m, l, v, t) {\n            var message = 'ERROR (' + v + ') ' + t;\n            var li = '<li><a class=\"error\" unselectable href=\"' + encodeURI('command:glsl-canvas.revealGlslLine?' + JSON.stringify([options.uri, Number(l), message])) + '\"><span class=\"line\">ERROR line ' + Number(l) + '</span> <span class=\"value\" title=\"' + v + '\">' + v + '</span> <span class=\"text\" title=\"' + t + '\">' + t + '</span></a></li>';\n            errors.push(li);\n            return li;\n        });\n        message.error.replace(/WARNING: \\d+:(\\d+): \\'(.*\\n*|.*|\\n*)\\' : (.+)/g, function (m, l, v, t) {\n            var li = '<li><a class=\"warning\" unselectable href=\"' + encodeURI('command:glsl-canvas.revealGlslLine?' + JSON.stringify([options.uri, Number(l), message])) + '\"><span class=\"line\">WARN line ' + Number(l) + '</span> <span class=\"text\" title=\"' + t + '\">' + t + '</span></a></li>';\n            warnings.push(li);\n            return li;\n        });\n        var output = '<div class=\"errors-content\"><p>glslCanvas error</p><ul>';\n        output += errors.join('\\n');\n        output += warnings.join('\\n');\n        output += '</ul></div>';\n        document.querySelector('.errors').setAttribute('class', 'errors active');\n        document.querySelector('.errors').innerHTML = output;\n        document.querySelector('body').setAttribute('class', 'idle');\n    }\n\n    function getResource(url, callback) {\n        var request = new XMLHttpRequest();\n        request.open('GET', url, true);\n        request.addEventListener('load', function () {\n            callback(request.responseText);\n        });\n        request.send();\n    }\n\n    window.addEventListener('load', init);\n\n    var GlslCanvasWrapper = function () {\n        // TODO LOAD CREATE MULTIPLE PROGRAMS\n        /*\n        lass GLProgram {\n        constructor (vertexShader, fragmentShader) {\n            this.uniforms = {};\n            this.program = gl.createProgram();\n\n            gl.attachShader(this.program, vertexShader);\n            gl.attachShader(this.program, fragmentShader);\n            gl.linkProgram(this.program);\n\n            if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n                throw gl.getProgramInfoLog(this.program);\n            }\n\n            const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n            for (let i = 0; i < uniformCount; i++) {\n                const uniformName = gl.getActiveUniform(this.program, i).name;\n                this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);\n            }\n        }\n        bind () {\n            gl.useProgram(this.program);\n        }\n        }\n        */\n\n        function GlslCanvasWrapper() {\n            return GlslCanvas();\n        }\n\n        GlslCanvas.prototype.render = render;\n        GlslCanvas.prototype.loadBuffers = loadBuffers;\n\n        function createFrameBuffer(gl, index, W, H, internalFormat, format, type, param) {\n            gl.activeTexture(gl.TEXTURE0 + index);\n            var texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, W, H, 0, format, type, null);\n            var frameBuffer = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            gl.viewport(0, 0, W, H);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            return [texture, frameBuffer, index];\n        }\n\n        function loadBuffers(buffers) {\n            var glsl = this,\n                gl = glsl.gl;\n            glsl.buffers = {};\n            var vertex = createShader(glsl, glsl.vertexString, gl.VERTEX_SHADER);\n            for (var key in buffers) {\n                var buffer = buffers[key];\n                var fragment = createShader(glsl, buffer.common + buffer.fragment, gl.FRAGMENT_SHADER);\n                // If Fragment shader fails load a empty one to sign the error\n                if (!fragment) {\n                    fragment = createShader(glsl, 'void main(){\\n\\tgl_FragColor = vec4(1.0);\\n}', gl.FRAGMENT_SHADER);\n                    glsl.isValid = false;\n                } else {\n                    glsl.isValid = true;\n                    buffer.frame = createFrameBuffer(gl, i, glsl.canvas.width, glsl.canvas.height, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gl.NEAREST);\n                }\n                // Create and use program\n                var program = createProgram(glsl, [vertex, fragment]);\n                buffer.program = program;\n                console.log('buffer', buffer);\n                glsl.buffers[key] = buffer;\n                // glsl.gl.useProgram(program);\n                // Delete shaders\n                gl.deleteShader(fragment);\n            }\n            gl.deleteShader(vertex);\n            gl.binder = function () {\n                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(0);\n                return function (destination) {\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, destination);\n                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n                };\n            }();\n        }\n\n        function render() {\n            var glsl = this,\n                gl = glsl.gl;\n\n            glsl.visible = isCanvasVisible(glsl.canvas);\n            if (glsl.forceRender || (glsl.animated && glsl.visible && !glsl.paused)) {\n                var date = new Date();\n                var now = performance.now();\n                glsl.timeDelta = (now - glsl.timePrev) / 1000.0;\n                glsl.timePrev = now;\n                if (glsl.nDelta > 1) {\n                    // set the delta time uniform\n                    glsl.uniform('1f', 'float', 'u_delta', glsl.timeDelta);\n                }\n\n                if (glsl.nTime > 1) {\n                    // set the elapsed time uniform\n                    glsl.uniform('1f', 'float', 'u_time', (now - glsl.timeLoad) / 1000.0);\n                }\n\n                if (glsl.nDate) {\n                    // Set date uniform: year/month/day/time_in_sec\n                    glsl.uniform('4f', 'float', 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);\n                }\n\n                // set the resolution uniform\n                glsl.uniform('2f', 'vec2', 'u_resolution', glsl.canvas.width, glsl.canvas.height);\n\n                glsl.texureIndex = 0;\n                for (var tex in glsl.textures) {\n                    glsl.uniformTexture(tex);\n                }\n\n                // TODO RENDER MULTIPLE BUFFERS            \n                if (glsl.buffers && Object.keys(glsl.buffers).length > 0) {\n                    for (var key in glsl.buffers) {\n                        var buffer = glsl.buffers[key];\n                        glsl.uniformTexture(key, buffer.frame[0], {\n                            filtering: 'mipmap',\n                            repeat: true,\n                        });\n                        gl.useProgram(buffer.program);\n                        gl.binder(buffer.frame);\n                    }\n                    gl.useProgram(glsl.program);\n                }\n\n                // Draw the rectangle.\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n                // Trigger event\n                glsl.trigger('render', {});\n\n                glsl.change = false;\n                glsl.forceRender = false;\n\n                /*\n                // Shadertoy uses technique called rendering to texture. Suppose gl is our WebGL context. First we need to create a texture first pass will draw to:\n                // desired size of the texture\n                var W = glsl.canvas.width,\n                    H = glsl.canvas.height;\n\n                var textureBuffer0 = gl.createTexture();\n                var frameBuffer0 = gl.createFramebuffer();\n                var u_buffer_0 = gl.getUniformLocation(glsl.program, \"u_buffer_0\");\n\n                gl.bindTexture(gl.TEXTURE_2D, textureBuffer0);\n                // allocate texture data.\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                // may be change texture parameters (at least magnification and\n                // minification filters since we won't render mip levels.\n                // Then we create framebuffer object so we can draw to our texture:\n                gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer0);\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureBuffer0, 0);\n                // Now we can draw:\n                gl.bindBuffer(gl.FRAMEBUFFER, frameBuffer0);\n                gl.viewport(0, 0, W, H);\n                // draw first pass, the one which supposed to write data for the channel 0\n                // it'll use fragment shader for bufferA\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n                // pass textureBuffer0 as channel 0\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, textureBuffer0);\n                gl.uniform1i(u_buffer_0, 0);\n                // draw second pass, the one with uses channel 0\n                // There 're a lot of materials about rendering to texture, for example here.\n                */\n            }\n        }\n\n        function createShader(glsl, source, type) {\n            var gl = glsl.gl;\n            var shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n            if (!compiled) {\n                // Something went wrong during compilation; get the error\n                var lastError = gl.getShaderInfoLog(shader);\n                console.error('*** Error compiling shader ' + shader + ':' + lastError);\n                glsl.trigger('error', {\n                    shader: shader,\n                    source: source,\n                    type: type,\n                    error: lastError\n                });\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        function createProgram(glsl, shaders, optAttribs, optLocations) {\n            var gl = glsl.gl;\n            var ii;\n            var program = gl.createProgram();\n            for (ii = 0; ii < shaders.length; ++ii) {\n                gl.attachShader(program, shaders[ii]);\n            }\n            if (optAttribs) {\n                for (ii = 0; ii < optAttribs.length; ++ii) {\n                    gl.bindAttribLocation(\n                        program,\n                        optLocations ? optLocations[ii] : ii,\n                        optAttribs[ii]);\n                }\n            }\n            gl.linkProgram(program);\n            // Check the link status\n            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n            if (!linked) {\n                // something went wrong with the link\n                lastError = gl.getProgramInfoLog(program);\n                console.log('Error in program linking:' + lastError);\n                gl.deleteProgram(program);\n                return null;\n            }\n            return program;\n        }\n\n        function isCanvasVisible(canvas) {\n            return ((canvas.getBoundingClientRect().top + canvas.height) > 0) && (canvas.getBoundingClientRect().top < (window.innerHeight || document.documentElement.clientHeight));\n        }\n\n        return GlslCanvasWrapper;\n\n    }();\n\n}());"]}