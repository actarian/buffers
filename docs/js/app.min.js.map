{"version":3,"sources":["docs/js/app.js"],"names":["GlslCanvasWrapper","GlslCanvas","prototype","TEXTURE_COUNT","BUFFER_COUNT","createBuffer","W","H","program","glsl","this","gl","index","getExtension","texture","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texImage2D","RGBA","FLOAT","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","buffer","createFramebuffer","console","log","resize","bindFramebuffer","FRAMEBUFFER","minW","Math","min","minH","pixels","Float32Array","readPixels","newIndex","newTexture","texSubImage2D","newBuffer","deleteTexture","createSwappableBuffer","input","output","swap","temp","render","name","useProgram","viewport","framebufferTexture2D","COLOR_ATTACHMENT0","drawArrays","TRIANGLES","load","fragString","vertString","line","vertexString","fragmentString","animated","nDelta","match","length","nTime","nDate","nMouse","search","lines","split","i","ext","pop","toLowerCase","setUniform","main","vertexShader","createShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","isValid","createProgram","deleteShader","change","trigger","forceRender","loadBuffers","buffers","vertex","key","fragment","common","bundle","canvas","width","height","loadUniforms","options","textures","uniformTexture","filtering","repeat","updateVariables","date","Date","now","performance","variables","prev","delta","timeLoad","time","year","getFullYear","month","getMonth","getDate","daytime","getHours","getMinutes","getSeconds","getMilliseconds","UpdateUniforms","uniform2f","getUniformLocation","uniform1f","uniform4f","uniform1i","resizeSwappableBuffers","Object","keys","renderGl","visible","getBoundingClientRect","top","window","innerHeight","document","documentElement","clientHeight","paused","setMouse","mouse","rect","x","left","right","y","bottom","_resize","source","type","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","lastError","getShaderInfoLog","error","shaders","optAttribs","optLocations","attachShader","bindAttribLocation","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","flag","apply","onGlslError","message","errors","warnings","replace","m","l","v","t","Number","li","encodeURI","JSON","stringify","uri","push","warning","join","querySelector","setAttribute","innerHTML","addEventListener","url","callback","request","linediff","RegExp","end","offset","substr","content","ri","premultipliedAlpha","preserveDrawingBuffer","backgroundColor","init","w","offsetWidth","h","offsetHeight","style","on","trim","clearTimeout","setTimeout","createCanvas","XMLHttpRequest","open","responseText","send"],"mappings":"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","file":"app.min.js","sourcesContent":["/* global window, document, console, GlslCanvas, CaptureService, GuiService, TrailsService, CameraService, Stats, dat */\n\n(function () {\n    'use strict';\n\n    var GlslCanvasWrapper = function () {\n\n        function GlslCanvasWrapper(canvas, options) {\n            return new GlslCanvas(canvas, options);\n        }\n\n        GlslCanvas.prototype.TEXTURE_COUNT = 0;\n        GlslCanvas.prototype.BUFFER_COUNT = 0;\n        GlslCanvas.prototype.createBuffer = createBuffer;\n        GlslCanvas.prototype.createSwappableBuffer = createSwappableBuffer;\n        GlslCanvas.prototype.load = load;\n        GlslCanvas.prototype.loadBuffers = loadBuffers;\n        GlslCanvas.prototype.loadUniforms = loadUniforms;\n        GlslCanvas.prototype.updateVariables = updateVariables;\n        GlslCanvas.prototype.UpdateUniforms = UpdateUniforms;\n        GlslCanvas.prototype.resizeSwappableBuffers = resizeSwappableBuffers;\n        GlslCanvas.prototype.renderGl = renderGl;\n        GlslCanvas.prototype.render = render;\n\n        var _setMouse = GlslCanvas.prototype.setMouse;\n        GlslCanvas.prototype.setMouse = setMouse;\n\n        var _resize = GlslCanvas.prototype.resize;\n        GlslCanvas.prototype.resize = resize;\n\n        // GlslCanvas.prototype.uniform = uniform;\n\n        function createBuffer(W, H, program) {\n            var glsl = this,\n                gl = glsl.gl,\n                index = glsl.TEXTURE_COUNT + glsl.BUFFER_COUNT;\n            glsl.BUFFER_COUNT++;\n            var float_texture_ext = gl.getExtension('OES_texture_float');\n            var texture = gl.createTexture();\n            gl.activeTexture(gl.TEXTURE0 + index);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, null);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            var buffer = gl.createFramebuffer();\n            // gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n            /*\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            gl.viewport(0, 0, W, H);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            */\n            console.log('createBuffer', index);\n            return {\n                index: index,\n                texture: texture,\n                buffer: buffer,\n                resize: resize,\n                W: W,\n                H: H,\n            };\n            function resize(W, H) {\n                gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n                var minW = Math.min(W, this.W);\n                var minH = Math.min(H, this.H);\n                var pixels = new Float32Array(minW * minH * 4);\n                gl.readPixels(0, 0, minW, minH, gl.RGBA, gl.FLOAT, pixels);\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                // create new texture;\n                var newIndex = glsl.TEXTURE_COUNT + glsl.BUFFER_COUNT;\n                // glsl.BUFFER_COUNT++; // reuse index\n                var newTexture = gl.createTexture();\n                gl.activeTexture(gl.TEXTURE0 + newIndex);\n                gl.bindTexture(gl.TEXTURE_2D, newTexture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, null);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                // copy\n                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, minW, minH, gl.RGBA, gl.FLOAT, pixels);\n                //\n                var newBuffer = gl.createFramebuffer();\n                //\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                gl.deleteTexture(texture);\n                //\n                gl.activeTexture(gl.TEXTURE0 + index);\n                gl.bindTexture(gl.TEXTURE_2D, newTexture);\n                index = this.index = index;\n                texture = this.texture = newTexture;\n                buffer = this.buffer = newBuffer;\n                this.W = W;\n                this.H = H;\n                console.log(index, W, H);\n                /*\n                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, W, H, 0);\n                gl.bindTexture(gl.TEXTURE_2D, texture);\n                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, W, H, 0);\n                //\n                gl.bindFramebuffer(gl.FRAMEBUFFER, newBuffer);\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, newTexture, 0);\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n                */\n                /*\n                var v = [0, 0, Math.min(this.mXres, oldXres), Math.min(this.mYres, oldYres)];\n                this.mRenderer.SetBlend(false);\n                this.mRenderer.SetViewport(v);\n                this.mRenderer.AttachShader(this.mProgramCopy);\n                var l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, \"pos\");\n                var vOld = [0, 0, oldXres, oldYres];\n                this.mRenderer.SetShaderConstant4FV(\"v\", vOld);\n\n                // Resize each double buffer\n                var texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, this.mXres, this.mYres, this.mRenderer.TEXFMT.C4F32, (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE, (needCopy) ? this.mBuffers[i].mTexture[0].mWrap : this.mRenderer.TEXWRP.CLAMP, null);\n                var target1 = this.mRenderer.CreateRenderTarget(texture1, null, null, null, null, false);\n\n                // Copy old buffers 1 to new buffer\n                this.mRenderer.SetRenderTarget(target1);\n                this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);\n                this.mRenderer.DrawUnitQuad_XY(l1);\n                mGL.bindBuffer(mGL.ARRAY_BUFFER, mVBO_Quad);\n                mGL.vertexAttribPointer(vpos, 2, mGL.FLOAT, false, 0, 0);\n                mGL.enableVertexAttribArray(vpos);\n                mGL.drawArrays(mGL.TRIANGLES, 0, 6);\n                mGL.disableVertexAttribArray(vpos);\n                mGL.bindBuffer(mGL.ARRAY_BUFFER, null);\n                // Deallocate old memory\n                this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);\n                this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);\n                // Store new buffers\n                this.mBuffers[i].mTexture = [texture1, texture2],\n                    this.mBuffers[i].mTarget = [target1, target2],\n                    this.mBuffers[i].mLastRenderDone = 0;\n                this.mRenderer.DettachTextures();\n                this.mRenderer.DetachShader();\n                this.mRenderer.SetRenderTarget(null);\n                */\n            }\n        }\n\n        function createSwappableBuffer(W, H, program) {\n            var glsl = this,\n                gl = glsl.gl;\n            var input = glsl.createBuffer(W, H, program);\n            var output = glsl.createBuffer(W, H, program);\n            return {\n                input: input,\n                output: output,\n                swap: function () {\n                    var temp = input;\n                    input = output;\n                    output = temp;\n                    this.input = input;\n                    this.output = output;\n                },\n                render: function (W, H, program, name) {\n                    gl.useProgram(program);\n                    // gl.uniform1i(gl.getUniformLocation(program, name), input.index); // removable\n                    gl.viewport(0, 0, W, H); // removable\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, input.buffer);\n                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, output.texture, 0);\n                    gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n                    /*\n                    // gl.activeTexture(gl.TEXTURE0);\n                    gl.bindTexture(gl.TEXTURE_2D, input.texture);\n                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, W, H, gl.RGBA, gl.FLOAT, null);\n                    */\n                    // gl.bindTexture(gl.TEXTURE_2D, null);\n                    // this.swap();\n\n                    /*\n                    var id = inp.id;\n                    texID[i] = buffers[id].mTexture[buffers[id].mLastRenderDone];\n                    resos[3 * i + 0] = xres;\n                    resos[3 * i + 1] = yres;\n                    resos[3 * i + 2] = 1;\n                    // hack. in webgl2.0 we have samplers, so we don't need this crap here\n                    var filter = this.mRenderer.FILTER.NONE;\n                    if (inp.mInfo.mSampler.filter === \"linear\") filter = this.mRenderer.FILTER.LINEAR;\n                    else if (inp.mInfo.mSampler.filter === \"mipmap\") filter = this.mRenderer.FILTER.MIPMAP;\n                    this.mRenderer.SetSamplerFilter(texID[i], filter);\n                    this.mTextureCallbackFun(this.mTextureCallbackObj, i, { texture: inp.image, data: buffers[id].mThumbnailBuffer }, false, 9, 1, -1, this.mID);\n                    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);\n                    */\n\n                    /*\n                     gl.activeTexture(gl.TEXTURE0 + input.index);\n                     gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, W, H, 0);\n                     */\n                    // gl.activeTexture(gl.TEXTURE0 + output.index);\n                    // gl.clear(gl.COLOR_BUFFER_BIT);\n                    /*\n                    gl.uniform1i(gl.getUniformLocation(program, name), output.index);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, output.buffer);\n                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, input.texture, 0);\n                    gl.drawArrays(gl.TRIANGLES, 0, 6);\n                    */\n                },\n                resize: function (W, H, program, name) {\n                    gl.useProgram(program);\n                    gl.viewport(0, 0, W, H); // removable\n                    this.input.resize(W, H);\n                    this.output.resize(W, H);\n                },\n            };\n        }\n\n        function resizeSwappableBuffers() {\n            var glsl = this,\n                gl = glsl.gl;\n            if (glsl.buffers && Object.keys(glsl.buffers).length > 0) {\n                var i = 0,\n                    W = gl.canvas.width,\n                    H = gl.canvas.height;\n                gl.viewport(0, 0, W, H);\n                for (var key in glsl.buffers) {\n                    var buffer = glsl.buffers[key];\n                    buffer.bundle.resize(W, H, buffer.program, buffer.name);\n                    /*\n                    gl.useProgram(buffer.program);\n                    // \n                    gl.activeTexture(gl.TEXTURE0 + i * 2);\n                    gl.bindTexture(gl.TEXTURE_2D, buffer.bundle.textureOut);\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                    // \n                    gl.activeTexture(gl.TEXTURE0 + i * 2 + 1);\n                    gl.bindTexture(gl.TEXTURE_2D, buffer.bundle.textureIn);\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                    */\n                    i++;\n                }\n                gl.useProgram(glsl.program);\n            }\n        }\n\n        /*\n        function resizeSwappableBuffer(oldXres, oldYres) {\n            var needCopy = (oldXres !== null && oldYres !== null);\n            // first time!\n            if (!needCopy) {\n                var thumnailRes = [256, 128];\n                for (var i = 0; i < this.mMaxBuffers; i++) {\n                    this.mBuffers[i] = {\n                        mTexture: [null, null],\n                        mTarget: [null, null],\n                        mLastRenderDone: 0,\n                        mThumbnailRenderTarget: null,//thumbnailRenderTarget,\n                        mThumbnailTexture: null,//thumbnailTexture,\n                        mThumbnailBuffer: null,//thumbnailBuffer,\n                        mThumbnailRes: thumnailRes\n                    };\n                }\n            }\n\n            // Prepare for rendering\n            if (needCopy) {\n                var v = [0, 0, Math.min(this.mXres, oldXres), Math.min(this.mYres, oldYres)];\n                this.mRenderer.SetBlend(false);\n                this.mRenderer.SetViewport(v);\n                this.mRenderer.AttachShader(this.mProgramCopy);\n                var l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, \"pos\");\n                var vOld = [0, 0, oldXres, oldYres];\n                this.mRenderer.SetShaderConstant4FV(\"v\", vOld);\n            }\n\n            // Resize each double buffer\n            for (var i = 0; i < this.mMaxBuffers; i++) {\n                var texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,\n                    this.mXres, this.mYres,\n                    this.mRenderer.TEXFMT.C4F32,\n                    (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,\n                    (needCopy) ? this.mBuffers[i].mTexture[0].mWrap : this.mRenderer.TEXWRP.CLAMP,\n                    null);\n                var target1 = this.mRenderer.CreateRenderTarget(texture1, null, null, null, null, false);\n\n                var texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,\n                    this.mXres, this.mYres,\n                    this.mRenderer.TEXFMT.C4F32,\n                    (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,\n                    (needCopy) ? this.mBuffers[i].mTexture[1].mWrap : this.mRenderer.TEXWRP.CLAMP,\n                    null);\n\n                var target2 = this.mRenderer.CreateRenderTarget(texture2, null, null, null, null, false);\n\n                if (needCopy) {\n                    // Copy old buffers 1 to new buffer\n                    this.mRenderer.SetRenderTarget(target1);\n                    this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);\n                    this.mRenderer.DrawUnitQuad_XY(l1);\n\n                    // Copy old buffers 2 to new buffer\n                    this.mRenderer.SetRenderTarget(target2);\n                    this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);\n                    this.mRenderer.DrawUnitQuad_XY(l1);\n\n                    // Deallocate old memory\n                    this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);\n                    this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);\n                    this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);\n                    this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);\n                    //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);\n                }\n                // Store new buffers\n                this.mBuffers[i].mTexture = [texture1, texture2],\n                    this.mBuffers[i].mTarget = [target1, target2],\n                    this.mBuffers[i].mLastRenderDone = 0;\n            }\n\n            if (needCopy) {\n                this.mRenderer.DettachTextures();\n                this.mRenderer.DetachShader();\n                this.mRenderer.SetRenderTarget(null);\n            }\n\n        }\n\n        function CreateTexture(type, xres, yres, format, filter, wrap, buffer) {\n            var glsl = this,\n                gl = glsl.gl;\n            var LEN = gl.UNSIGNED_BYTE; // 16\n            // var LEN = gl.FLOAT; // 32;\n\n            var id = gl.createTexture();\n            var glFoTy = iFormatPI2GL(format);\n            var glWrap = gl.REPEAT;\n            if (wrap === me.TEXWRP.CLAMP) {\n                glWrap = gl.CLAMP_TO_EDGE;\n            }\n            if (type === me.TEXTYPE.T2D) {\n                gl.bindTexture(gl.TEXTURE_2D, id);\n                //if (buffer==null)\n                //gl.texStorage2D(gl.TEXTURE_2D, 0, gl.RGBA, xres, yres);\n                //else\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, xres, yres, 0, gl.RGBA, LEN, buffer);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, glWrap);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, glWrap);\n                if (filter === me.FILTER.NONE) {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                } else if (filter === me.FILTER.LINEAR) {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                } else if (filter === me.FILTER.MIPMAP) {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                } else {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                }\n                gl.bindTexture(gl.TEXTURE_2D, null);\n            } else if (type === me.TEXTYPE.T3D) {\n                if (mIs20) {\n                    gl.bindTexture(gl.TEXTURE_3D, id);\n                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_BASE_LEVEL, 0);\n                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAX_LEVEL, Math.log2(xres));\n                    if (filter === me.FILTER.NONE) {\n                        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                    } else if (filter === me.FILTER.LINEAR) {\n                        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                    } else if (filter === me.FILTER.MIPMAP) {\n                        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                    } else {\n                        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);\n                        gl.generateMipmap(gl.TEXTURE_3D);\n                    }\n                    gl.texImage3D(gl.TEXTURE_3D, 0, gl.RGBA, xres, yres, yres, 0, gl.RGBA, LEN, buffer);\n                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, glWrap);\n                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, glWrap);\n                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, glWrap);\n                    if (filter === me.FILTER.MIPMAP) {\n                        gl.generateMipmap(gl.TEXTURE_3D);\n                    }\n                    gl.bindTexture(gl.TEXTURE_3D, null);\n                } else {\n                    return null;\n                }\n            } else {\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, id);\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);\n            }\n            return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip: false };\n        };\n\n        function CreateRenderTarget(color0, color1, color2, color3, depth, wantZbuffer) {\n            var id = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, id);\n            if (depth === null) {\n                if (wantZbuffer === true) {\n                    var zb = gl.createRenderbuffer();\n                    gl.bindRenderbuffer(gl.RENDERBUFFER, zb);\n                    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, color0.mXres, color0.mYres);\n\n                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, zb);\n                }\n            } else {\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depth.mObjectID, 0);\n            }\n            if (color0 != null) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, color0.mObjectID, 0);\n            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {\n                return null;\n            }\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            return {\n                mObjectID: id\n            };\n        }\n        */\n\n        function load(fragString, vertString, line) {\n            var glsl = this, gl = glsl.gl;\n            // Load vertex shader if there is one\n            if (vertString) {\n                glsl.vertexString = vertString;\n            }\n            // Load fragment shader if there is one\n            if (fragString) {\n                glsl.fragmentString = fragString;\n            }\n            glsl.animated = false;\n            glsl.nDelta = (glsl.fragmentString.match(/u_delta/g) || []).length;\n            glsl.nTime = (glsl.fragmentString.match(/u_time/g) || []).length;\n            glsl.nDate = (glsl.fragmentString.match(/u_date/g) || []).length;\n            glsl.nMouse = (glsl.fragmentString.match(/u_mouse/g) || []).length;\n            glsl.animated = glsl.nDate > 1 || glsl.nTime > 1 || glsl.nMouse > 1;\n            var nTextures = glsl.fragmentString.search(/sampler2D/g);\n            if (nTextures) {\n                var lines = glsl.fragmentString.split('\\n');\n                for (var i = 0; i < lines.length; i++) {\n                    var match = lines[i].match(/uniform\\s*sampler2D\\s*([\\w]*);\\s*\\/\\/\\s*([\\w|\\:\\/\\/|\\.|\\-|\\_]*)/i);\n                    if (match) {\n                        var ext = match[2].split('.').pop().toLowerCase();\n                        if (match[1] && match[2] && (ext === 'jpg' || ext === 'jpeg' || ext === 'png' || ext === 'ogv' || ext === 'webm' || ext === 'mp4')) {\n                            glsl.setUniform(match[1], match[2]);\n                        }\n                    }\n                    var main = lines[i].match(/\\s*void\\s*main\\s*/g);\n                    if (main) {\n                        break;\n                    }\n                }\n            }\n            var vertexShader = createShader(glsl, glsl.vertexString, gl.VERTEX_SHADER);\n            var fragmentShader = createShader(glsl, glsl.fragmentString, gl.FRAGMENT_SHADER, line);\n            // If Fragment shader fails load a empty one to sign the error\n            if (!fragmentShader) {\n                fragmentShader = createShader(glsl, 'void main(){\\n\\tgl_FragColor = vec4(1.0);\\n}', gl.FRAGMENT_SHADER);\n                glsl.isValid = false;\n            } else {\n                glsl.isValid = true;\n            }\n            // Create and use program\n            var program = createProgram(glsl, [vertexShader, fragmentShader]);//, [0,1],['a_texcoord','a_position']);\n            gl.useProgram(program);\n            // Delete shaders\n            // gl.detachShader(program, vertexShader);\n            // gl.detachShader(program, fragmentShader);\n            gl.deleteShader(vertexShader);\n            gl.deleteShader(fragmentShader);\n            glsl.program = program;\n            glsl.change = true;\n            // Trigger event\n            glsl.trigger('load', {});\n            glsl.forceRender = true;\n        }\n\n        function loadBuffers(buffers) {\n            var glsl = this,\n                gl = glsl.gl,\n                i = 0;\n            glsl.buffers = {};\n            var vertex = createShader(glsl, glsl.vertexString, gl.VERTEX_SHADER);\n            for (var key in buffers) {\n                var buffer = buffers[key];\n                var fragment = createShader(glsl, buffer.common + buffer.fragment, gl.FRAGMENT_SHADER, buffer.line);\n                if (!fragment) {\n                    fragment = createShader(glsl, 'void main(){\\n\\tgl_FragColor = vec4(1.0);\\n}', gl.FRAGMENT_SHADER);\n                    glsl.isValid = false;\n                } else {\n                    glsl.isValid = true;\n                }\n                var program = createProgram(glsl, [vertex, fragment]);\n                buffer.name = 'u_buffer_' + i;\n                buffer.program = program;\n                buffer.bundle = glsl.createSwappableBuffer(glsl.canvas.width, glsl.canvas.height, program);\n                // console.log(i, key, buffer.common + buffer.fragment, buffer.bundle);\n                glsl.buffers[key] = buffer;\n                gl.deleteShader(fragment);\n                i++;\n            }\n            gl.deleteShader(vertex);\n        }\n\n        /*\n        function ub() {\n            if (tex.mType === me.TEXTYPE.T2D) {\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, tex.mObjectID);\n                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, tex.mVFlip);\n                gl.texSubImage2D(gl.TEXTURE_2D, 0, x0, y0, xres, yres, gl.RGBA, gl.UNSIGNED_BYTE, buffer);\n                gl.bindTexture(gl.TEXTURE_2D, null);\n            }\n        }\n        */\n        /*\n                function _loadBuffers(buffers) {\n                    var glsl = this,\n                        gl = glsl.gl,\n                        i = 0;\n                    glsl.buffers = {};\n                    gl.bundle = function (program, i, W, H) {\n                        gl.useProgram(program);\n                        var textureOut = gl.createTexture();\n                        gl.activeTexture(gl.TEXTURE0 + i * 2); //           <-- out activate\n                        gl.bindTexture(gl.TEXTURE_2D, textureOut);\n                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                        var textureIn = gl.createTexture();\n                        gl.activeTexture(gl.TEXTURE0 + i * 2 + 1); //       <-- in activate\n                        gl.bindTexture(gl.TEXTURE_2D, textureIn);\n                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                        var buffer = gl.createFramebuffer();\n                        return {\n                            textureIn: textureIn,\n                            textureOut: textureOut,\n                            render: function (W, H) {\n                                gl.useProgram(program);\n                                gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n                                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureOut, 0);\n                                gl.activeTexture(gl.TEXTURE0 + i * 2); //           <-- out activate\n                                gl.bindTexture(gl.TEXTURE_2D, textureOut); //       <-- out bind\n                                gl.viewport(0, 0, W, H);\n                                gl.drawArrays(gl.TRIANGLES, 0, 6); //               <-- out draw\n                                gl.activeTexture(gl.TEXTURE0 + i * 2 + 1); //                   <-- in activate\n                                gl.bindTexture(gl.TEXTURE_2D, textureIn); //                    <-- in bind\n                                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, W, H, 0); // <-- in copy                        \n                            }\n                        };\n                    };\n        \n                    var vertex = createShader(glsl, glsl.vertexString, gl.VERTEX_SHADER);\n                    for (var key in buffers) {\n                        var buffer = buffers[key];\n                        var fragment = createShader(glsl, buffer.common + buffer.fragment, gl.FRAGMENT_SHADER);\n                        if (!fragment) {\n                            fragment = createShader(glsl, 'void main(){\\n\\tgl_FragColor = vec4(1.0);\\n}', gl.FRAGMENT_SHADER);\n                            glsl.isValid = false;\n                        } else {\n                            glsl.isValid = true;\n                        }\n                        var program = createProgram(glsl, [vertex, fragment]);\n                        buffer.program = program;\n                        buffer.bundle = gl.bundle(program, i, glsl.canvas.width, glsl.canvas.height);\n                        // console.log(i, key, buffer.common + buffer.fragment, buffer.bundle);\n                        glsl.buffers[key] = buffer;\n                        gl.deleteShader(fragment);\n                        i++;\n                    }\n                    gl.deleteShader(vertex);\n                }\n        */\n\n        function resize() {\n            var glsl = this;\n            var flag = _resize.apply(glsl);\n            if (flag) {\n                glsl.resizeSwappableBuffers();\n            }\n            return flag;\n        }\n\n        function loadUniforms(options) {\n            if (options.textures) {\n                for (var key in options.textures) {\n                    glsl.uniformTexture('u_texture_' + key, options.textures[key], {\n                        filtering: 'mipmap',\n                        repeat: true,\n                    });\n                }\n            }\n        }\n\n        function setMouse(mouse) {\n            // _setMouse(mouse);\n            var glsl = this,\n                gl = glsl.gl;\n            var rect = this.canvas.getBoundingClientRect();\n            if (mouse && mouse.x && mouse.x >= rect.left && mouse.x <= rect.right && mouse.y && mouse.y >= rect.top && mouse.y <= rect.bottom) {\n                var x = mouse.x - rect.left;\n                var y = this.canvas.height - (mouse.y - rect.top);\n                // this.uniform('2f', 'vec2', 'u_mouse', x, y);\n                if (glsl.buffers && Object.keys(glsl.buffers).length > 0) {\n                    for (var key in glsl.buffers) {\n                        var buffer = glsl.buffers[key];\n                        gl.useProgram(buffer.program);\n                        gl.uniform2f(gl.getUniformLocation(buffer.program, 'u_mouse'), x, y);\n                    }\n                }\n                gl.useProgram(glsl.program);\n                gl.uniform2f(gl.getUniformLocation(glsl.program, 'u_mouse'), x, y);\n            }\n        }\n\n        function updateVariables() {\n            var glsl = this,\n                gl = glsl.gl;\n            var date = new Date();\n            var now = performance.now();\n            glsl.variables = glsl.variables || {};\n            glsl.variables.prev = glsl.variables.prev || now;\n            glsl.variables.delta = (now - glsl.variables.prev) / 1000.0;\n            glsl.variables.prev = now;\n            glsl.variables.load = glsl.timeLoad;\n            glsl.variables.time = (now - glsl.timeLoad) / 1000.0;\n            glsl.variables.year = date.getFullYear();\n            glsl.variables.month = date.getMonth();\n            glsl.variables.date = date.getDate();\n            glsl.variables.daytime = date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001;\n        }\n\n        function UpdateUniforms(program, key) {\n            var glsl = this,\n                gl = glsl.gl;\n\n            gl.useProgram(program);\n\n            gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), glsl.canvas.width, glsl.canvas.height);\n\n            if (glsl.nTime > 1) {\n                gl.uniform1f(gl.getUniformLocation(program, 'u_time'), glsl.variables.time);\n            }\n\n            if (glsl.nDelta > 1) {\n                gl.uniform1f(gl.getUniformLocation(program, 'u_delta'), glsl.variables.delta);\n            }\n\n            if (glsl.nDate) {\n                // Set date uniform: year/month/day/time_in_sec\n                gl.uniform4f(gl.getUniformLocation(program, 'u_date'), glsl.variables.year, glsl.variables.month, glsl.variables.date, glsl.variables.daytime);\n            }\n\n            /*\n            glsl.texureIndex = 0;\n            for (var key in glsl.textures) {\n                glsl.uniformTexture(key, {\n                    filtering: 'mipmap',\n                    repeat: true,\n                });\n            }\n            */\n\n            for (var key in glsl.buffers) {\n                var buffer = glsl.buffers[key];\n                gl.uniform1i(gl.getUniformLocation(program, buffer.name), buffer.bundle.input.index);\n            }\n\n            /*\n            var i = 0;\n            for (var key in glsl.buffers) {\n                program.buffers = program.buffers || {};\n                if (!program.buffers[\"u_buffer_\" + i]) {\n                    program.buffers[\"u_buffer_\" + i] = true;\n                    gl.uniform1i(gl.getUniformLocation(program, \"u_buffer_\" + i), i * 2 + 1);\n                }\n                i++;\n            }\n            */\n\n            /*\n            var i = 0,\n                au = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            while (i < au) {\n                var info = gl.getActiveUniform(program, i);\n                console.log('info', key, info);\n                i++;\n            }\n            console.log('status', key, 'link', gl.getProgramParameter(program, gl.LINK_STATUS), 'validate', gl.getProgramParameter(program, gl.VALIDATE_STATUS));\n            */\n\n            // console.log(key, 'u_time', u_time.location);\n\n        }\n\n        function renderGl() {\n            var glsl = this,\n                gl = glsl.gl,\n                W = gl.canvas.width,\n                H = gl.canvas.height;\n            glsl.updateVariables();\n            gl.viewport(0, 0, W, H);\n            if (glsl.buffers && Object.keys(glsl.buffers).length > 0) {\n                for (var key in glsl.buffers) {\n                    var buffer = glsl.buffers[key];\n                    glsl.UpdateUniforms(buffer.program, key);\n                    buffer.bundle.render(W, H, buffer.program, buffer.name);\n                    // buffer.program.blit(buffer.bundle.output.buffer);\n                    buffer.bundle.swap();\n                }\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            }\n            glsl.UpdateUniforms(glsl.program, 'main');\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n        }\n\n        function render() {\n            var glsl = this,\n                gl = glsl.gl;\n            glsl.visible = isCanvasVisible(glsl.canvas);\n            // glsl.animated = true;\n            if (glsl.forceRender || (glsl.animated && glsl.visible && !glsl.paused)) {\n                glsl.renderGl();\n                glsl.change = false;\n                glsl.forceRender = false;\n                glsl.trigger('render', {});\n            }\n        }\n\n        function createShader(glsl, source, type, line) {\n            var gl = glsl.gl;\n            var shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n            if (!compiled) {\n                var lastError = gl.getShaderInfoLog(shader);\n                console.log(lastError);\n                console.error('*** Error compiling shader ' + shader + ':' + lastError);\n                glsl.trigger('error', {\n                    shader: shader,\n                    source: source,\n                    type: type,\n                    error: lastError,\n                    line: line || 0,\n                });\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        function createProgram(glsl, shaders, optAttribs, optLocations) {\n            var gl = glsl.gl;\n            var i;\n            var program = gl.createProgram();\n            for (i = 0; i < shaders.length; ++i) {\n                gl.attachShader(program, shaders[i]);\n            }\n            if (optAttribs) {\n                for (i = 0; i < optAttribs.length; ++i) {\n                    gl.bindAttribLocation(program, optLocations ? optLocations[i] : i, optAttribs[i]);\n                }\n            }\n            gl.linkProgram(program);\n            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n            if (!linked) {\n                var lastError = gl.getProgramInfoLog(program);\n                console.log('Error in program linking:' + lastError);\n                gl.deleteProgram(program);\n                return null;\n            }\n            /*\n            program.blit = function () {\n                gl.useProgram(program);\n                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(0);\n                return function (destination) {\n                    gl.useProgram(program);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, destination);\n                    // gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n                    gl.drawArrays(gl.TRIANGLES, 0, 6);\n                };\n            }();\n            */\n            /*\n            var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n            for (var i = 0; i < numAttribs; ++i) {\n                var attribInfo = gl.getActiveAttrib(program, i);\n                if (!attribInfo) {\n                    break;\n                }\n                console.log(gl.getAttribLocation(program, attribInfo.name), attribInfo.name);\n            }\n            */\n            return program;\n        }\n\n        function isCanvasVisible(canvas) {\n            return ((canvas.getBoundingClientRect().top + canvas.height) > 0) && (canvas.getBoundingClientRect().top < (window.innerHeight || document.documentElement.clientHeight));\n        }\n\n        return GlslCanvasWrapper;\n\n    }();\n\n    var options = window.options = {\n        vertex: '',\n        fragment: '',\n        main: '',\n        buffers: {},\n    };\n\n    function init() {\n        getResource(\"shaders/buffers/milk.glsl\", function (fragment) {\n            var source = fragment; var line;\n            options.main = null;\n            // (?<=\\/{2} u_buffer_)(\\d+).*((.|\\n)*?)(?=\\/{2} [u_buffer|main]|\\z)\n            // (?<=\\/{2} main).*((.|\\n)*?)(?=\\/{2} u_buffer|\\z)\n            fragment = fragment.replace(new RegExp('(/{2} u_buffer_)(\\\\d+).*((.|\\\\n)*?)(?=/{2} u_buffer|/{2} main|$)', 'g'), function (match, name, i, fragment, end, offset) {\n                // console.log('u_buffer_.replace', arguments);\n                line = source.substr(0, offset).split('\\n').length;\n                // console.log('line', line);\n                options.buffers['u_buffer_' + i] = {\n                    fragment: fragment,\n                    line: line,\n                };\n                return '';\n            });\n\n            fragment = fragment.replace(new RegExp('(/{2} main).*((.|\\\\n)*)(?=/{2} u_buffer|$)', 'g'), function (match, name, main, end, offset) {\n                options.main = main;\n                return '';\n            });\n\n            var linediff = fragment.split('\\n').length;\n\n            line = 0;\n            if (options.main) {\n                source.replace(new RegExp('(/{2} main).*((.|\\\\n)*)(?=/{2} u_buffer|$)', 'g'), function (match, name, main, end, offset) {\n                    line = source.substr(0, offset).split('\\n').length - linediff;\n                    return '';\n                });\n            }\n\n            // console.log('getResource', fragment, options.buffers);\n            for (var key in options.buffers) {\n                options.buffers[key].common = fragment;\n                options.buffers[key].line -= linediff;\n            }\n\n            options.fragment = fragment + (options.main || '');\n            options.line = line;\n            // console.log('fragment', options.fragment);\n            createCanvas();\n        });\n    }\n\n    function createCanvas() {\n        var content = document.querySelector('.content');\n        var canvas = document.querySelector('.shader');\n\n        resize(true);\n\n        var glsl = new GlslCanvasWrapper(canvas, {\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: true,\n            backgroundColor: 'rgba(1,1,1,1)',\n        });\n        glsl.animated = true;\n        glsl.on('error', onGlslError);\n        glsl.on('render', function () {\n            // glsl.forceRender = true;\n        });\n\n        load();\n\n        function load() {\n            var options = window.options;\n            document.querySelector('.errors').setAttribute('class', 'errors');\n            document.querySelector('.welcome').setAttribute('class', 'welcome');\n            options.vertex = options.vertex.trim().length > 0 ? options.vertex : null;\n            options.fragment = options.fragment.trim().length > 0 ? options.fragment : null;\n            if (options.fragment || options.vertex) {\n                document.querySelector('body').setAttribute('class', 'ready');\n            } else {\n                document.querySelector('body').setAttribute('class', 'empty');\n            }\n            glsl.load(options.fragment, options.vertex, options.line);\n            glsl.loadBuffers(options.buffers);\n            glsl.loadUniforms(options);\n\n            // console.log('glsl', glsl);\n            /*\n            gui.load(options.uniforms);\n            glsl.setUniforms(gui.uniforms());\n            */\n        }\n\n        function resize(init) {\n            var w = content.offsetWidth;\n            var h = content.offsetHeight;\n            canvas.style.width = w + 'px';\n            canvas.style.height = h + 'px';\n            if (init) {\n                canvas.width = w;\n                canvas.height = h;\n            } else {\n                glsl.resize();\n            }\n        }\n\n        var ri;\n\n        function onResize() {\n            if (ri) {\n                clearTimeout(ri);\n            }\n            ri = setTimeout(resize, 50);\n        }\n\n        window.addEventListener('resize', onResize);\n\n        resize();\n    }\n\n    function onGlslError(message) {\n        console.log('onGlslError.error', message);\n        var options = window.options;\n        var errors = [],\n            warnings = [];\n        message.error.replace(/ERROR: \\d+:(\\d+): \\'(.+)\\' : (.+)/g, function (m, l, v, t) {\n            var line = Number(l) + message.line;\n            var error = 'ERROR (' + v + ') ' + t;\n            var li = '<li><a class=\"error\" unselectable href=\"' + encodeURI('command:glsl-canvas.revealGlslLine?' + JSON.stringify([options.uri, line, error])) + '\"><span class=\"line\">ERROR line ' + line + '</span> <span class=\"value\" title=\"' + v + '\">' + v + '</span> <span class=\"text\" title=\"' + t + '\">' + t + '</span></a></li>';\n            errors.push(li);\n            return li;\n        });\n        message.error.replace(/WARNING: \\d+:(\\d+): \\'(.*\\n*|.*|\\n*)\\' : (.+)/g, function (m, l, v, t) {\n            var line = Number(l) + message.line;\n            var warning = 'WARNING (' + v + ') ' + t;\n            var li = '<li><a class=\"warning\" unselectable href=\"' + encodeURI('command:glsl-canvas.revealGlslLine?' + JSON.stringify([options.uri, line, warning])) + '\"><span class=\"line\">WARN line ' + line + '</span> <span class=\"text\" title=\"' + t + '\">' + t + '</span></a></li>';\n            warnings.push(li);\n            return li;\n        });\n        var output = '<div class=\"errors-content\"><p>glslCanvas error</p><ul>';\n        output += errors.join('\\n');\n        output += warnings.join('\\n');\n        output += '</ul></div>';\n        document.querySelector('.errors').setAttribute('class', 'errors active');\n        document.querySelector('.errors').innerHTML = output;\n        document.querySelector('body').setAttribute('class', 'idle');\n    }\n\n    function getResource(url, callback) {\n        var request = new XMLHttpRequest();\n        request.open('GET', url, true);\n        request.addEventListener('load', function () {\n            callback(request.responseText);\n        });\n        request.send();\n    }\n\n    window.addEventListener('load', init);\n\n}());"]}