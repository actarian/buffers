{"version":3,"sources":["docs/js/app.js"],"names":["GlslCanvasWrapper","createShader","glsl","source","type","gl","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","lastError","getShaderInfoLog","console","error","trigger","deleteShader","createProgram","shaders","optAttribs","optLocations","i","program","length","attachShader","bindAttribLocation","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","log","deleteProgram","GlslCanvas","prototype","loadBuffers","buffers","this","bundle","W","H","useProgram","texture","createTexture","buffer","createFramebuffer","uniform","getUniformLocation","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","link","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","viewport","activeTexture","TEXTURE0","vertex","vertexString","VERTEX_SHADER","key","fragment","common","FRAGMENT_SHADER","isValid","canvas","width","height","loadUniforms","options","textures","uniformTexture","filtering","repeat","updateVariables","date","Date","now","performance","variables","prev","delta","load","timeLoad","time","year","getFullYear","month","getMonth","getDate","daytime","getHours","getMinutes","getSeconds","getMilliseconds","updateUniforms","uniform1f","uniform2f","p","uniform1i","updateBuffers","Object","keys","drawArrays","TRIANGLES","method","name","value","Array","slice","call","arguments","uniforms","location","apply","concat","render","visible","getBoundingClientRect","top","window","innerHeight","document","documentElement","clientHeight","animated","forceRender","paused","change","main","onGlslError","message","errors","warnings","replace","m","l","v","t","li","encodeURI","JSON","stringify","uri","Number","push","output","join","querySelector","setAttribute","innerHTML","addEventListener","url","callback","request","RegExp","match","content","resize","ri","premultipliedAlpha","preserveDrawingBuffer","backgroundColor","init","w","offsetWidth","h","offsetHeight","style","on","trim","clearTimeout","setTimeout","createCanvas","XMLHttpRequest","open","responseText","send"],"mappings":"CAEC,WACG,aAEA,IAAIA,EAAoB,WA+RpB,SAASC,EAAaC,EAAMC,EAAQC,GAChC,IAAIC,EAAKH,EAAKG,GACVC,EAASD,EAAGJ,aAAaG,GAI7B,GAHAC,EAAGE,aAAaD,EAAQH,GACxBE,EAAGG,cAAcF,IACFD,EAAGI,mBAAmBH,EAAQD,EAAGK,gBACjC,CACX,IAAIC,EAAYN,EAAGO,iBAAiBN,GASpC,OARAO,QAAQC,MAAM,8BAAgCR,EAAS,IAAMK,GAC7DT,EAAKa,QAAQ,SACTT,OAAQA,EACRH,OAAQA,EACRC,KAAMA,EACNU,MAAOH,IAEXN,EAAGW,aAAaV,GACT,KAEX,OAAOA,EAGX,SAASW,EAAcf,EAAMgB,EAASC,EAAYC,GAC9C,IACIC,EADAhB,EAAKH,EAAKG,GAEViB,EAAUjB,EAAGY,gBACjB,IAAKI,EAAI,EAAGA,EAAIH,EAAQK,SAAUF,EAC9BhB,EAAGmB,aAAaF,EAASJ,EAAQG,IAErC,GAAIF,EACA,IAAKE,EAAI,EAAGA,EAAIF,EAAWI,SAAUF,EACjChB,EAAGoB,mBAAmBH,EAASF,EAAeA,EAAaC,GAAKA,EAAGF,EAAWE,IAKtF,GAFAhB,EAAGqB,YAAYJ,IACFjB,EAAGsB,oBAAoBL,EAASjB,EAAGuB,aACnC,CACT,IAAIjB,EAAYN,EAAGwB,kBAAkBP,GAGrC,OAFAT,QAAQiB,IAAI,4BAA8BnB,GAC1CN,EAAG0B,cAAcT,GACV,KAEX,OAAOA,EAOX,OA/SAU,WAAWC,UAAUC,YA2BrB,SAAqBC,GACjB,IAAIjC,EAAOkC,KACP/B,EAAKH,EAAKG,GACVgB,EAAI,EACRnB,EAAKiC,WACL9B,EAAGgC,OAAS,SAAUf,EAASD,EAAGiB,EAAGC,GACjClC,EAAGmC,WAAWlB,GACd,IAAImB,EAAUpC,EAAGqC,gBACbC,EAAStC,EAAGuC,oBACZC,EAAUxC,EAAGyC,mBAAmBxB,EAAS,YAAcD,GAO3D,OANAhB,EAAG0C,YAAY1C,EAAG2C,WAAYP,GAC9BpC,EAAG4C,WAAW5C,EAAG2C,WAAY,EAAG3C,EAAG6C,KAAMZ,EAAGC,EAAG,EAAGlC,EAAG6C,KAAM7C,EAAG8C,cAAe,MAC7E9C,EAAG+C,cAAc/C,EAAG2C,WAAY3C,EAAGgD,mBAAoBhD,EAAGiD,SAC1DjD,EAAG+C,cAAc/C,EAAG2C,WAAY3C,EAAGkD,mBAAoBlD,EAAGiD,SAC1DjD,EAAG+C,cAAc/C,EAAG2C,WAAY3C,EAAGmD,eAAgBnD,EAAGoD,eACtDpD,EAAG+C,cAAc/C,EAAG2C,WAAY3C,EAAGqD,eAAgBrD,EAAGoD,gBAElDhB,QAASA,EACTE,OAAQA,EACRE,QAASA,EACTc,KAAM,WACFtD,EAAGmC,WAAWlB,GACdjB,EAAGuD,gBAAgBvD,EAAGwD,YAAalB,GACnCtC,EAAGyD,qBAAqBzD,EAAGwD,YAAaxD,EAAG0D,kBAAmB1D,EAAG2C,WAAYP,EAAS,GAItFpC,EAAG2D,SAAS,EAAG,EAAG1B,EAAGC,GAQrBlC,EAAG4D,cAAc5D,EAAG6D,SAAW7C,GAC/BhB,EAAG0C,YAAY1C,EAAG2C,WAAYP,MAO1C,IAAI0B,EAASlE,EAAaC,EAAMA,EAAKkE,aAAc/D,EAAGgE,eACtD,IAAK,IAAIC,KAAOnC,EAAS,CACrB,IAAIQ,EAASR,EAAQmC,GACjBC,EAAWtE,EAAaC,EAAMyC,EAAO6B,OAAS7B,EAAO4B,SAAUlE,EAAGoE,iBAEjEF,EAIDrE,EAAKwE,SAAU,GAHfH,EAAWtE,EAAaC,EAAM,+CAAgDG,EAAGoE,iBACjFvE,EAAKwE,SAAU,GAKnB,IAAIpD,EAAUL,EAAcf,GAAOiE,EAAQI,IAC3C5B,EAAOrB,QAAUA,EAGjBqB,EAAON,OAAShC,EAAGgC,OAAOf,EAASD,EAAGnB,EAAKyE,OAAOC,MAAO1E,EAAKyE,OAAOE,QAIrE3E,EAAKiC,QAAQmC,GAAO3B,EAGpBtC,EAAGW,aAAauD,GAChBlD,IAEJhB,EAAGW,aAAamD,IA/FpBnC,WAAWC,UAAU6C,aAiHrB,SAAsBC,GAClB,GAAIA,EAAQC,SACR,IAAK,IAAIV,KAAOS,EAAQC,SACpB9E,KAAK+E,eAAe,aAAeX,EAAKS,EAAQC,SAASV,IACrDY,UAAW,SACXC,QAAQ,KArHxBnD,WAAWC,UAAUmD,gBA2HrB,WACI,IAAIlF,EAAOkC,KAEPiD,GADKnF,EAAKG,GACH,IAAIiF,MACXC,EAAMC,YAAYD,MACtBrF,EAAKuF,UAAYvF,EAAKuF,cACtBvF,EAAKuF,UAAUC,KAAOxF,EAAKuF,UAAUC,MAAQH,EAC7CrF,EAAKuF,UAAUE,OAASJ,EAAMrF,EAAKuF,UAAUC,MAAQ,IACrDxF,EAAKuF,UAAUC,KAAOH,EACtBrF,EAAKuF,UAAUG,KAAO1F,EAAK2F,SAC3B3F,EAAKuF,UAAUK,MAAQP,EAAMrF,EAAK2F,UAAY,IAC9C3F,EAAKuF,UAAUM,KAAOV,EAAKW,cAC3B9F,EAAKuF,UAAUQ,MAAQZ,EAAKa,WAC5BhG,EAAKuF,UAAUJ,KAAOA,EAAKc,UAC3BjG,EAAKuF,UAAUW,QAA4B,KAAlBf,EAAKgB,WAAwC,GAApBhB,EAAKiB,aAAoBjB,EAAKkB,aAAwC,KAAzBlB,EAAKmB,mBAxIxGxE,WAAWC,UAAUwE,eA2IrB,SAAwBnF,EAASgD,GAC7B,IAAIpE,EAAOkC,KACP/B,EAAKH,EAAKG,GAYdA,EAAGqG,UAAUrG,EAAGyC,mBAAmBxB,EAAS,UAAWpB,EAAKuF,UAAUK,MAYtEzF,EAAGsG,UAAUtG,EAAGyC,mBAAmBxB,EAAS,gBAAiBpB,EAAKyE,OAAOC,MAAO1E,EAAKyE,OAAOE,QAE5F,IAAIxD,EAAI,EACR,IAAK,IAAIuF,KAAK1G,EAAKiC,QACf9B,EAAGwG,UAAUxG,EAAGyC,mBAAmBxB,EAAS,YAAcD,GAAIA,GAC9DA,KAzKRW,WAAWC,UAAU6E,cAyNrB,WACI,IAAI5G,EAAOkC,KACP/B,EAAKH,EAAKG,GACd,GAAIH,EAAKiC,SAA8C,EAAnC4E,OAAOC,KAAK9G,EAAKiC,SAASZ,OAAY,CACtD,IAAK,IAAI+C,KAAOpE,EAAKiC,QAAS,CAC1B,IAAIQ,EAASzC,EAAKiC,QAAQmC,GAC1BjE,EAAGmC,WAAWG,EAAOrB,SACrBpB,EAAKuG,eAAe9D,EAAOrB,QAASgD,GACpC3B,EAAON,OAAOsB,OAEdtD,EAAG4G,WAAW5G,EAAG6G,UAAW,EAAG,GAEnC7G,EAAGmC,WAAWtC,EAAKoB,SACnBpB,EAAKuG,eAAevG,EAAKoB,QAAS,QAClCjB,EAAGuD,gBAAgBvD,EAAGwD,YAAa,MACnCxD,EAAG2D,SAAS,EAAG,EAAG3D,EAAGsE,OAAOC,MAAOvE,EAAGsE,OAAOE,UAvOrD7C,WAAWC,UAAUY,QAqMrB,SAAiBvB,EAAS6F,EAAQ/G,EAAMgH,GACpC,IAAIlH,EAAOkC,KACP/B,EAAKH,EAAKG,GACVgH,EAAQC,MAAMrF,UAAUsF,MAAMC,KAAKC,WAAWF,MAAM,GACxDrH,EAAKwH,SAAWxH,EAAKwH,aACrBxH,EAAKwH,SAASN,GAAQlH,EAAKwH,SAASN,OACpC,IAAIvE,EAAU3C,EAAKwH,SAASN,GAGxBvE,EAAQuE,KAAOA,EACfvE,EAAQwE,MAAQA,EAChBxE,EAAQzC,KAAOA,EACfyC,EAAQsE,OAAS,UAAYA,EAC7BtE,EAAQ8E,SAAWtH,EAAGyC,mBAAmBxB,EAAS8F,GAClD/G,EAAGwC,EAAQsE,QAAQS,MAAMvH,GAAKwC,EAAQ8E,UAAUE,OAAOhF,EAAQwE,QAEnE,OAAOxE,GApNXb,WAAWC,UAAU6F,OA0OrB,WACI,IAAI5H,EAAOkC,KACP/B,EAAKH,EAAKG,GACdH,EAAK6H,SAwDgBpD,EAxDUzE,EAAKyE,OAyD2B,EAAtDA,EAAOqD,wBAAwBC,IAAMtD,EAAOE,QAAiBF,EAAOqD,wBAAwBC,KAAOC,OAAOC,aAAeC,SAASC,gBAAgBC,eAxD3JpI,EAAKqI,UAAW,GACZrI,EAAKsI,aAAgBtI,EAAKqI,UAAYrI,EAAK6H,UAAY7H,EAAKuI,UAC5DvI,EAAKkF,kBACLlF,EAAK4G,gBACLzG,EAAG4G,WAAW5G,EAAG6G,UAAW,EAAG,GAC/BhH,EAAKa,QAAQ,aACbb,EAAKwI,QAAS,EACdxI,EAAKsI,aAAc,GAgD3B,IAAyB7D,GA/SzB,SAA2BA,EAAQI,GAC/B,OAAO,IAAI/C,WAAW2C,EAAQI,IA7Bd,GAmVpBA,EAAUmD,OAAOnD,SACjBZ,OAAQ,GACRI,SAAU,GACVoE,KAAM,GACNxG,YAkGJ,SAASyG,EAAYC,GACjBhI,QAAQiB,IAAI,oBAAqB+G,EAAQ/H,OACzC,IAAIiE,EAAUmD,OAAOnD,QACjB+D,KACAC,KACJF,EAAQ/H,MAAMkI,QAAQ,qCAAsC,SAAUC,EAAGC,EAAGC,EAAGC,GAC3E,IAAIP,EAAU,UAAYM,EAAI,KAAOC,EACjCC,EAAK,2CAA6CC,UAAU,sCAAwCC,KAAKC,WAAWzE,EAAQ0E,IAAKC,OAAOR,GAAIL,KAAa,mCAAqCa,OAAOR,GAAK,sCAAwCC,EAAI,KAAOA,EAAI,qCAAuCC,EAAI,KAAOA,EAAI,mBAE3T,OADAN,EAAOa,KAAKN,GACLA,IAEXR,EAAQ/H,MAAMkI,QAAQ,iDAAkD,SAAUC,EAAGC,EAAGC,EAAGC,GACvF,IAAIC,EAAK,6CAA+CC,UAAU,sCAAwCC,KAAKC,WAAWzE,EAAQ0E,IAAKC,OAAOR,GAAIL,KAAa,kCAAoCa,OAAOR,GAAK,qCAAuCE,EAAI,KAAOA,EAAI,mBAErQ,OADAL,EAASY,KAAKN,GACPA,IAEX,IAAIO,EAAS,0DACbA,GAAUd,EAAOe,KAAK,MACtBD,GAAUb,EAASc,KAAK,MACxBD,GAAU,cACVxB,SAAS0B,cAAc,WAAWC,aAAa,QAAS,iBACxD3B,SAAS0B,cAAc,WAAWE,UAAYJ,EAC9CxB,SAAS0B,cAAc,QAAQC,aAAa,QAAS,QAYzD7B,OAAO+B,iBAAiB,OAjIxB,WAwHA,IAAqBC,EAAKC,EAClBC,EADaF,EAvHL,uBAuHUC,EAvHc,SAAU5F,GAiB1C,IAAK,IAAID,KANTC,GARAA,EAAWA,EAASyE,QAAQ,IAAIqB,OAAO,kEAAmE,KAAM,SAAUC,EAAOlD,EAAM/F,EAAGkD,GAKtI,OAHAQ,EAAQ5C,QAAQ,YAAcd,IAC1BkD,SAAUA,GAEP,MAGSyE,QAAQ,IAAIqB,OAAO,6CAA8C,KAAM,SAAUC,EAAOlD,EAAMuB,GAE9G,OADA5D,EAAQ4D,KAAOA,EACR,KAIK5D,EAAQ5C,QACpB4C,EAAQ5C,QAAQmC,GAAKE,OAASD,EAGlCQ,EAAQR,SAAWA,GAAYQ,EAAQ4D,MAAQ,IAMvD,WACI,IAAI4B,EAAUnC,SAAS0B,cAAc,YACjCnF,EAASyD,SAAS0B,cAAc,WAEpCU,GAAO,GAEP,IA+CIC,EAjCI1F,EAdJ7E,EAAO,IAAIF,EAAkB2E,GAC7B+F,oBAAoB,EACpBC,uBAAuB,EACvBC,gBAAiB,kBA+BrB,SAASJ,EAAOK,GACZ,IAAIC,EAAIP,EAAQQ,YACZC,EAAIT,EAAQU,aAChBtG,EAAOuG,MAAMtG,MAAQkG,EAAI,KACzBnG,EAAOuG,MAAMrG,OAASmG,EAAI,KACtBH,GACAlG,EAAOC,MAAQkG,EACfnG,EAAOE,OAASmG,GAEhB9K,EAAKsK,SAtCbtK,EAAKqI,UAAW,EAChBrI,EAAKiL,GAAG,QAASvC,GACjB1I,EAAKiL,GAAG,SAAU,WACdjL,EAAKsI,aAAc,IAMfzD,EAAUmD,OAAOnD,QACrBqD,SAAS0B,cAAc,WAAWC,aAAa,QAAS,UACxD3B,SAAS0B,cAAc,YAAYC,aAAa,QAAS,WACzDhF,EAAQZ,OAAwC,EAA/BY,EAAQZ,OAAOiH,OAAO7J,OAAawD,EAAQZ,OAAS,KACrEY,EAAQR,SAA4C,EAAjCQ,EAAQR,SAAS6G,OAAO7J,OAAawD,EAAQR,SAAW,KACvEQ,EAAQR,UAAYQ,EAAQZ,OAC5BiE,SAAS0B,cAAc,QAAQC,aAAa,QAAS,SAErD3B,SAAS0B,cAAc,QAAQC,aAAa,QAAS,SAEzD7J,EAAK0F,KAAKb,EAAQR,SAAUQ,EAAQZ,QACpCjE,EAAKgC,YAAY6C,EAAQ5C,SACzBjC,EAAK4E,aAAaC,GA8BtBmD,OAAO+B,iBAAiB,SAPxB,WACQQ,GACAY,aAAaZ,GAEjBA,EAAKa,WAAWd,EAAQ,MAK5BA,IApEIe,KAiGAnB,EAAU,IAAIoB,gBACVC,KAAK,MAAOvB,GAAK,GACzBE,EAAQH,iBAAiB,OAAQ,WAC7BE,EAASC,EAAQsB,gBAErBtB,EAAQuB,SA3dhB","file":"app.min.js","sourcesContent":["/* global window, document, console, GlslCanvas, CaptureService, GuiService, TrailsService, CameraService, Stats, dat */\n\n(function () {\n    'use strict';\n\n    var GlslCanvasWrapper = function () {\n        // TODO LOAD CREATE MULTIPLE PROGRAMS\n        /*\n        lass GLProgram {\n        constructor (vertexShader, fragmentShader) {\n            this.uniforms = {};\n            this.program = gl.createProgram();\n\n            gl.attachShader(this.program, vertexShader);\n            gl.attachShader(this.program, fragmentShader);\n            gl.linkProgram(this.program);\n\n            if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n                throw gl.getProgramInfoLog(this.program);\n            }\n\n            const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n            for (let i = 0; i < uniformCount; i++) {\n                const uniformName = gl.getActiveUniform(this.program, i).name;\n                this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);\n            }\n        }\n        bind () {\n            gl.useProgram(this.program);\n        }\n        }\n        */\n\n        function GlslCanvasWrapper(canvas, options) {\n            return new GlslCanvas(canvas, options);\n        }\n\n        GlslCanvas.prototype.loadBuffers = loadBuffers;\n        GlslCanvas.prototype.loadUniforms = loadUniforms;\n        GlslCanvas.prototype.updateVariables = updateVariables;\n        GlslCanvas.prototype.updateUniforms = updateUniforms;\n        GlslCanvas.prototype.updateBuffers = updateBuffers;\n        GlslCanvas.prototype.uniform = uniform;\n        GlslCanvas.prototype.render = render;\n        /*\n        function createFrameBuffer(gl, i, W, H) {\n            gl.activeTexture(gl.TEXTURE0 + i);\n            var texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            var buffer = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            gl.viewport(0, 0, W, H);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            console.log(W, H, i);\n            return [texture, buffer, i];\n        }\n        */\n\n        function loadBuffers(buffers) {\n            var glsl = this,\n                gl = glsl.gl,\n                i = 0;\n            glsl.buffers = {};\n            gl.bundle = function (program, i, W, H) {\n                gl.useProgram(program);\n                var texture = gl.createTexture();\n                var buffer = gl.createFramebuffer();\n                var uniform = gl.getUniformLocation(program, \"u_buffer_\" + i);\n                gl.bindTexture(gl.TEXTURE_2D, texture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                return {\n                    texture: texture,\n                    buffer: buffer,\n                    uniform: uniform,\n                    link: function () {\n                        gl.useProgram(program);\n                        gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n                        /*\n                        gl.bindBuffer(gl.FRAMEBUFFER, buffer);\n                        */\n                        gl.viewport(0, 0, W, H);\n                        /*\n                        // draw first pass, the one which supposed to write data for the channel i\n                        // it'll use fragment shader for bufferA\n                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n                        // pass texture as channel i\n                        */\n                        gl.activeTexture(gl.TEXTURE0 + i);\n                        gl.bindTexture(gl.TEXTURE_2D, texture);\n                        // draw second pass, the one with uses channel i\n                        // There 're a lot of materials about rendering to texture, for example here.\n                    }\n                };\n            };\n\n            var vertex = createShader(glsl, glsl.vertexString, gl.VERTEX_SHADER);\n            for (var key in buffers) {\n                var buffer = buffers[key];\n                var fragment = createShader(glsl, buffer.common + buffer.fragment, gl.FRAGMENT_SHADER);\n                // If Fragment shader fails load a empty one to sign the error\n                if (!fragment) {\n                    fragment = createShader(glsl, 'void main(){\\n\\tgl_FragColor = vec4(1.0);\\n}', gl.FRAGMENT_SHADER);\n                    glsl.isValid = false;\n                } else {\n                    glsl.isValid = true;\n                }\n                // Create and use program\n                var program = createProgram(glsl, [vertex, fragment]);\n                buffer.program = program;\n\n                // buffer.frame = createFrameBuffer(gl, i, glsl.canvas.width, glsl.canvas.height);\n                buffer.bundle = gl.bundle(program, i, glsl.canvas.width, glsl.canvas.height);\n                // console.log(i, key, buffer.common + buffer.fragment, buffer.bundle);\n\n                // console.log('buffer', buffer);\n                glsl.buffers[key] = buffer;\n                // glsl.gl.useProgram(program);\n                // Delete shaders\n                gl.deleteShader(fragment);\n                i++;\n            }\n            gl.deleteShader(vertex);\n            /*\n            gl.binder = function () {\n                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(0);\n                return function (buffer) {\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n                    // gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n                    gl.drawArrays(gl.TRIANGLES, 0, 6);\n                };\n            }();\n            */\n        }\n\n        function loadUniforms(options) {\n            if (options.textures) {\n                for (var key in options.textures) {\n                    glsl.uniformTexture('u_texture_' + key, options.textures[key], {\n                        filtering: 'mipmap',\n                        repeat: true,\n                    });\n                }\n            }\n        }\n\n        function updateVariables() {\n            var glsl = this,\n                gl = glsl.gl;\n            var date = new Date();\n            var now = performance.now();\n            glsl.variables = glsl.variables || {};\n            glsl.variables.prev = glsl.variables.prev || now;\n            glsl.variables.delta = (now - glsl.variables.prev) / 1000.0;\n            glsl.variables.prev = now;\n            glsl.variables.load = glsl.timeLoad;\n            glsl.variables.time = (now - glsl.timeLoad) / 1000.0;\n            glsl.variables.year = date.getFullYear();\n            glsl.variables.month = date.getMonth();\n            glsl.variables.date = date.getDate();\n            glsl.variables.daytime = date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001;\n        }\n\n        function updateUniforms(program, key) {\n            var glsl = this,\n                gl = glsl.gl;\n\n            /*\n            // if (glsl.nDelta > 1) {\n            // set the delta time uniform\n            glsl.uniform(program, '1f', 'float', 'u_delta', glsl.variables.delta);\n            // }\n            */\n\n            // if (glsl.nTime > 1) {\n            // set the elapsed time uniform\n            // var u_time = glsl.uniform(program, '1f', 'float', 'u_time', glsl.variables.time);\n            gl.uniform1f(gl.getUniformLocation(program, 'u_time'), glsl.variables.time);\n            // }\n\n            /*\n            // if (glsl.nDate) {\n            // Set date uniform: year/month/day/time_in_sec\n            glsl.uniform(program, '4f', 'float', 'u_date', glsl.variables.year, glsl.variables.month, glsl.variables.date, glsl.variables.daytime);\n            // }\n            */\n\n            // set the resolution uniform\n            // var u_reolution = glsl.uniform(program, '2f', 'vec2', 'u_resolution', glsl.canvas.width, glsl.canvas.height);\n            gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), glsl.canvas.width, glsl.canvas.height);\n\n            var i = 0;\n            for (var p in glsl.buffers) {\n                gl.uniform1i(gl.getUniformLocation(program, \"u_buffer_\" + i), i); // texture unit 0\n                i++;\n            }\n            // console.log('updateUniforms', glsl.variables.time);\n\n            /*\n            glsl.texureIndex = 0;\n            for (var key in glsl.textures) {\n                glsl.uniformTexture(key, {\n                    filtering: 'mipmap',\n                    repeat: true,\n                });\n            }\n            */\n\n            /*\n            var i = 0,\n                au = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            while (i < au) {\n                var info = gl.getActiveUniform(program, i);\n                console.log('info', key, info);\n                i++;\n            }\n            console.log('status', key, 'link', gl.getProgramParameter(program, gl.LINK_STATUS), 'validate', gl.getProgramParameter(program, gl.VALIDATE_STATUS));\n            */\n\n            // console.log(key, 'u_time', u_time.location);\n\n        }\n\n        function uniform(program, method, type, name) {\n            var glsl = this,\n                gl = glsl.gl;\n            var value = Array.prototype.slice.call(arguments).slice(3);\n            glsl.uniforms = glsl.uniforms || {};\n            glsl.uniforms[name] = glsl.uniforms[name] || {};\n            var uniform = glsl.uniforms[name];\n            var change = true; // isDiff(uniform.value, value);\n            if (change || glsl.change || uniform.location === undefined || uniform.value === undefined) {\n                uniform.name = name;\n                uniform.value = value;\n                uniform.type = type;\n                uniform.method = 'uniform' + method;\n                uniform.location = gl.getUniformLocation(program, name);\n                gl[uniform.method].apply(gl, [uniform.location].concat(uniform.value));\n            }\n            return uniform;\n        }\n\n        function updateBuffers() {\n            var glsl = this,\n                gl = glsl.gl;\n            if (glsl.buffers && Object.keys(glsl.buffers).length > 0) {\n                for (var key in glsl.buffers) {\n                    var buffer = glsl.buffers[key];\n                    gl.useProgram(buffer.program);\n                    glsl.updateUniforms(buffer.program, key);\n                    buffer.bundle.link();\n                    // gl.bindFramebuffer(gl.FRAMEBUFFER, buffer.bundle.buffer);\n                    gl.drawArrays(gl.TRIANGLES, 0, 6);\n                }\n                gl.useProgram(glsl.program);\n                glsl.updateUniforms(glsl.program, 'main');\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n            }\n        }\n\n        function render() {\n            var glsl = this,\n                gl = glsl.gl;\n            glsl.visible = isCanvasVisible(glsl.canvas);\n            glsl.animated = true;\n            if (glsl.forceRender || (glsl.animated && glsl.visible && !glsl.paused)) {\n                glsl.updateVariables();\n                glsl.updateBuffers();\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n                glsl.trigger('render', {});\n                glsl.change = false;\n                glsl.forceRender = false;\n            }\n        }\n\n        function createShader(glsl, source, type) {\n            var gl = glsl.gl;\n            var shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n            if (!compiled) {\n                var lastError = gl.getShaderInfoLog(shader);\n                console.error('*** Error compiling shader ' + shader + ':' + lastError);\n                glsl.trigger('error', {\n                    shader: shader,\n                    source: source,\n                    type: type,\n                    error: lastError\n                });\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        function createProgram(glsl, shaders, optAttribs, optLocations) {\n            var gl = glsl.gl;\n            var i;\n            var program = gl.createProgram();\n            for (i = 0; i < shaders.length; ++i) {\n                gl.attachShader(program, shaders[i]);\n            }\n            if (optAttribs) {\n                for (i = 0; i < optAttribs.length; ++i) {\n                    gl.bindAttribLocation(program, optLocations ? optLocations[i] : i, optAttribs[i]);\n                }\n            }\n            gl.linkProgram(program);\n            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n            if (!linked) {\n                var lastError = gl.getProgramInfoLog(program);\n                console.log('Error in program linking:' + lastError);\n                gl.deleteProgram(program);\n                return null;\n            }\n            return program;\n        }\n\n        function isCanvasVisible(canvas) {\n            return ((canvas.getBoundingClientRect().top + canvas.height) > 0) && (canvas.getBoundingClientRect().top < (window.innerHeight || document.documentElement.clientHeight));\n        }\n\n        return GlslCanvasWrapper;\n\n    }();\n\n    var options = window.options = {\n        vertex: '',\n        fragment: '',\n        main: '',\n        buffers: {},\n    };\n\n    function init() {\n        getResource(\"shaders/buffers.glsl\", function (fragment) {\n            // (?<=\\/{2} u_buffer_)(\\d+).*((.|\\n)*?)(?=\\/{2} [u_buffer|main]|\\z)\n            // (?<=\\/{2} main).*((.|\\n)*?)(?=\\/{2} u_buffer|\\z)\n            fragment = fragment.replace(new RegExp('(/{2} u_buffer_)(\\\\d+).*((.|\\\\n)*?)(?=/{2} [u_buffer|main]|\\\\z)', 'g'), function (match, name, i, fragment) {\n                // console.log('u_buffer_.replace', arguments);\n                options.buffers['u_buffer_' + i] = {\n                    fragment: fragment,\n                };\n                return '';\n            });\n\n            fragment = fragment.replace(new RegExp('(/{2} main).*((.|\\\\n)*)(?=/{2} u_buffer|$)', 'g'), function (match, name, main) {\n                options.main = main;\n                return '';\n            });\n\n            // console.log('getResource', fragment, options.buffers);\n            for (var key in options.buffers) {\n                options.buffers[key].common = fragment;\n            }\n\n            options.fragment = fragment + (options.main || '');\n            // console.log('fragment', options.fragment);\n            createCanvas();\n        });\n    }\n\n    function createCanvas() {\n        var content = document.querySelector('.content');\n        var canvas = document.querySelector('.shader');\n\n        resize(true);\n\n        var glsl = new GlslCanvasWrapper(canvas, {\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: true,\n            backgroundColor: 'rgba(1,1,1,1)',\n        });\n        glsl.animated = true;\n        glsl.on('error', onGlslError);\n        glsl.on('render', function () {\n            glsl.forceRender = true;\n        });\n\n        load();\n\n        function load() {\n            var options = window.options;\n            document.querySelector('.errors').setAttribute('class', 'errors');\n            document.querySelector('.welcome').setAttribute('class', 'welcome');\n            options.vertex = options.vertex.trim().length > 0 ? options.vertex : null;\n            options.fragment = options.fragment.trim().length > 0 ? options.fragment : null;\n            if (options.fragment || options.vertex) {\n                document.querySelector('body').setAttribute('class', 'ready');\n            } else {\n                document.querySelector('body').setAttribute('class', 'empty');\n            }\n            glsl.load(options.fragment, options.vertex);\n            glsl.loadBuffers(options.buffers);\n            glsl.loadUniforms(options);\n            // console.log('glsl', glsl);\n            /*\n            gui.load(options.uniforms);\n            glsl.setUniforms(gui.uniforms());\n            */\n        }\n\n        function resize(init) {\n            var w = content.offsetWidth;\n            var h = content.offsetHeight;\n            canvas.style.width = w + 'px';\n            canvas.style.height = h + 'px';\n            if (init) {\n                canvas.width = w;\n                canvas.height = h;\n            } else {\n                glsl.resize();\n            }\n        }\n\n        var ri;\n\n        function onResize() {\n            if (ri) {\n                clearTimeout(ri);\n            }\n            ri = setTimeout(resize, 50);\n        }\n\n        window.addEventListener('resize', onResize);\n\n        resize();\n    }\n\n    function onGlslError(message) {\n        console.log('onGlslError.error', message.error);\n        var options = window.options;\n        var errors = [],\n            warnings = [];\n        message.error.replace(/ERROR: \\d+:(\\d+): \\'(.+)\\' : (.+)/g, function (m, l, v, t) {\n            var message = 'ERROR (' + v + ') ' + t;\n            var li = '<li><a class=\"error\" unselectable href=\"' + encodeURI('command:glsl-canvas.revealGlslLine?' + JSON.stringify([options.uri, Number(l), message])) + '\"><span class=\"line\">ERROR line ' + Number(l) + '</span> <span class=\"value\" title=\"' + v + '\">' + v + '</span> <span class=\"text\" title=\"' + t + '\">' + t + '</span></a></li>';\n            errors.push(li);\n            return li;\n        });\n        message.error.replace(/WARNING: \\d+:(\\d+): \\'(.*\\n*|.*|\\n*)\\' : (.+)/g, function (m, l, v, t) {\n            var li = '<li><a class=\"warning\" unselectable href=\"' + encodeURI('command:glsl-canvas.revealGlslLine?' + JSON.stringify([options.uri, Number(l), message])) + '\"><span class=\"line\">WARN line ' + Number(l) + '</span> <span class=\"text\" title=\"' + t + '\">' + t + '</span></a></li>';\n            warnings.push(li);\n            return li;\n        });\n        var output = '<div class=\"errors-content\"><p>glslCanvas error</p><ul>';\n        output += errors.join('\\n');\n        output += warnings.join('\\n');\n        output += '</ul></div>';\n        document.querySelector('.errors').setAttribute('class', 'errors active');\n        document.querySelector('.errors').innerHTML = output;\n        document.querySelector('body').setAttribute('class', 'idle');\n    }\n\n    function getResource(url, callback) {\n        var request = new XMLHttpRequest();\n        request.open('GET', url, true);\n        request.addEventListener('load', function () {\n            callback(request.responseText);\n        });\n        request.send();\n    }\n\n    window.addEventListener('load', init);\n\n}());"]}